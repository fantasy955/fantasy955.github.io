# 题目

[655. 输出二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/print-binary-tree/)

> 给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则：
>
> 树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。
> 矩阵的列数 n 应该等于 2height+1 - 1 。
> 根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。
> 对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1] 。
> 继续这一过程，直到树中的所有节点都妥善放置。
> 任意空单元格都应该包含空字符串 "" 。
> 返回构造得到的矩阵 res 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/print-binary-tree
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 代码

```c++
#include<string>
#include<unity> // to_string
#include<math.h> // pow

class Solution {
public:
    vector<vector<string>> printTree(TreeNode* root) {
        if (root == nullptr){
            return {{}};
        }
        queue<TreeNode*> nodeQue;
        queue<TreeNode*> nodesAll;
        nodesAll.push(root);
        nodeQue.push(root);
        int height = 0;
        while(nodeQue.size()){
            int i = nodeQue.size();
            while(i--){
                TreeNode* node = nodeQue.front();
                nodeQue.pop();
                if (node->left != nullptr){
                    nodeQue.push(node->left);
                }
                if (node->right != nullptr){
                    nodeQue.push(node->right); 
                }
                nodesAll.push(node->left);
                nodesAll.push(node->right);
            }
            height++;
        }
        vector<vector<string>> ans(height);
        int col = pow(2, height)-1;
        for(int i=0; i<height; i++){
            ans[i].resize(col);
        }

        int h = 0;
        unordered_map<TreeNode*, int> indexMap(height);
        nodeQue.push(root);
        indexMap[root] = col / 2;
        ans[h++][col / 2] = to_string(root->val);
        while(nodeQue.size()){
            int s = nodeQue.size();
            while(s--){
                TreeNode* node = nodeQue.front();
                int c = indexMap[node];
                nodeQue.pop();
                TreeNode* left = node->left;
                int target = c - pow(2, height-1-h);
                if (left != nullptr){
                    ans[h][target] = to_string(left->val);
                    indexMap[left] = target;
                    nodeQue.push(left);
                }
                TreeNode* right = node->right;
                target = c + pow(2, height-1-h);
                if (right != nullptr){
                    ans[h][target] = to_string(right->val);
                    indexMap[right] = target;
                    nodeQue.push(right);
                }
            }
            h++;
        }

        return ans;
    }
};

```

# 运行结果

![image-20220822171454167](assets/image-20220822171454167.png)