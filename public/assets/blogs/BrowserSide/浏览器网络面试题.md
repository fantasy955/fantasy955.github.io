# HTTP协议

[快速了解HTTP协议 - 掘金 (juejin.cn)](https://juejin.cn/post/7034498604639354916#heading-9)

> 请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体
>
> 状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体

## 请求报文

## 响应报文

## header



## body



# [2022年我的面试万字总结（浏览器网络篇） - 掘金 (juejin.cn)](https://juejin.cn/post/7149438206419664927#heading-2)

## 请求类型

- get，幂等，对服务器资源没有影响，例如请求图片资源；
- post，对服务器资源有影响，例如注册用户，**创建数据**；
- put，向服务器传送数据，服务器修改数据，**更新数据**；

## HTTP状态码

- 304，客户端有缓存，并且内容没有更新；

## Ajax

全称 `Asynchronous Javascript And XML(异步的js与xml)`

用js发异步请求。

**Ajax的核心是XMLHTTPRequest**。

## DNS解析过程

- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步

- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步

- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址

- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址

- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果

- 本地DNS服务器将返回结果保存在缓存中，便于下次使用

- 本地DNS服务器将返回结果返回给浏览器

## TCP三次握手，为什么是三次



# 跨域

[[前端面试题总结\] ⭐️ 从莉莉丝到滴滴--我的成长之路 - 掘金 (juejin.cn)](https://juejin.cn/post/7146151385707315213#heading-3)

## JSONP

[JSONP原理及实现 - 简书 (jianshu.com)](https://www.jianshu.com/p/88bb82718517)

1. 前端构造一个函数，将函数挂载到`window`上。

   ```html
   <script type='text/javascript'>
       window.jsonpCallback = function (res) {
           console.log(res)
       }
   </script>
   ```

2. 构造`script`标签，进行跨域请求，指定回调函数名称。

   ```html
   <script src='http://localhost:8080/api/jsonp?id=1&cb=jsonpCallback' type='text/javascript'></script>
   ```

3. 后端接收到请求参数和前端的回调函数名称，构造一个字符串，字符串内容为指向前端回调函数: `callback(res)`。

   ```js
   const Koa = require('koa');
   const app = new Koa();
   const items = [{ id: 1, title: 'title1' }, { id: 2, title: 'title2' }]
   
   app.use(async (ctx, next) => {
     if (ctx.path === '/api/jsonp') {
       const { cb, id } = ctx.query;
       const title = items.find(item => item.id == id)['title']
       ctx.body = `${cb}(${JSON.stringify({title})})`;
       return;
     }
   })
   console.log('listen 8080...')
   app.listen(8080);
   ```

4. 第二个`script`接收到服务器返回的数据，该标签等价于：

   ```html
   <!-- <script src='http://localhost:8080/api/jsonp?id=1&cb=jsonpCallback' type='text/javascript'></script> -->
   <script type="text/javascript">
       jsonpCallback({ title: 'title1' })
   </script>
   ```

   

# Get和Post请求

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

[Http 浅谈Get和POST的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7028198183222116382)

**POST 方法会产生两个TCP数据包？** 有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。

**HTTP 协议没有明确规定 POST 会产生两个 TCP 数据包。**

所以，header 和 body 分开发送是浏览器或框架的特定处理行为，并不是POST方法本身的性质。

## 区别

get请求和post请求都能带请求体，只是浏览器会忽视，使用nodejs的话能发送带请求体的get请求。

# Axios

[axios 的理解和使用 axios.create(对axios请求进行二次封装) 拦截器 取消请求(axios.CancelToken) - 全情海洋 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fsg6/p/13204535.html)

## 二次封装

- `Axios = axios.createAxios`
  [Axios 实例 | Axios 中文文档 | Axios 中文网 (axios-http.cn)](https://www.axios-http.cn/docs/instance)
- `axios.cancelToken`
  [取消请求 | Axios 中文文档 | Axios 中文网 (axios-http.cn)](https://www.axios-http.cn/docs/cancellation)

- `Axios.interceptors.request.use`
  请求拦截。添加cancelToken或取消已经发出的请求，自动携带token。
- `Axios.interceptors.response.use`
  响应拦截。自动刷新token，权限错误处理（跳转登录页面）。
  根据后端返回的状态码（自己封装的信息）自动重定向。
