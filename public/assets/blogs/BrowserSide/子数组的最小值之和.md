# 题目

[907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/)

> 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。
>
> 由于答案可能很大，因此 返回答案模 10^9 + 7 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/sum-of-subarray-minimums
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

## 分析

首先是题目，一开始没看懂，求的是**子数组最小值**之和，而不是**子数组的和**的和。

后者只需要获取子数组，然后记录每个子数组的和，最后累加。

而这题，我们不仅要获得子数组，还要记录子数组中的最小值，最后对所有最小值求和。

```c++
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> monoStack;
        vector<int> left(n), right(n);
      // left[i]记录以arr[i]作为右边界，且arr[i]为该子数组最小值，的子数组数量
      // right[i]记录以arr[i]为左边界，且arr[i]为该子数组最小值，的子数组数量
        for (int i = 0; i < n; i++) {
          // 栈记录左边最小元素的下标、
          // 所有大于arr[i]的元素出栈
          // 遇到比arr[i]小的元素停止
          // monoStack中保存[0:i-1]最小元素的下标
          // monoStack[0] < monoStack[1] < monoStack[2]
            while (!monoStack.empty() && arr[i] <= arr[monoStack.back()]) {
                monoStack.pop_back();
            }
          // left[i] 表示左边小于arr[i]的元素的个数	
            left[i] = i - (monoStack.empty() ? -1 : monoStack.back());
            monoStack.emplace_back(i);
        }
        monoStack.clear();
        for (int i = n - 1; i >= 0; i--) {
          // 为什么不能使用等于
          // 以[1,2, 2]为例，在计算left[i]时，left[1] = 1, left[2] = 2
          // 即[2,2]已经被考虑过了
            while (!monoStack.empty() && arr[i] < arr[monoStack.back()]) {
                monoStack.pop_back();
            }
            right[i] = (monoStack.empty() ? n : monoStack.back()) - i;
            monoStack.emplace_back(i);
        }
        long long ans = 0;
        long long mod = 1e9 + 7;
        for (int i = 0; i < n; i++) {
            ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod; 
        }
        return ans;
    }
};

```



# 扩展

## 求连续子数组

求子数组不应该用递归，以`[3,1,2,4]`为例，使用递归的话，会对之后的元素进行重复遍历；

正确的思路是求以arr[i]开头的连续数组。

即`[]`;

`3`,`3,1`,`3,1,2`,`3,1,2,4`;

`1`,`1,2`;