在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两 种。**前者用于服务器，后者用于浏览器**。

ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以 及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 比如，CommonJS 模块就是对象，输入时必须查找对象属性。

```
// CommonJS模块
let { stat, exists, readFile } = require('fs');
// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;

```

上面代码的实质是**整体加载 fs 模块**（即加载 fs 的所有方法），**生成一个对象 （ _fs ）**，然后再从这个对象上面读取3个方法。这种加载称为“**运行时加载**”，因 为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

```
// ES6模块
import { stat, exists, readFile } from 'fs';
```

ES6 **模块不是对象**，而是通过 export 命令**显式指定输出**的代码，再通 过 import 命令输入。

上面代码的实质是从 fs 模块加载3个方法，其他方法不加载。这种加载称为“编译 时加载”或者静态加载，即 ES6 可以在**编译时**就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了**没法引用 ES6 模块本身，因为 它不是对象**。

由于 ES6 模块是**编译时加**载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠 静态分析实现的功能。

# 模块导入方法

[ES6](./ES6.md)

# export命令

export 命令规定的是**对外的接口**，必须与模块内部的变量建 立一一对应关系。

```
// 报错
export 1;
// 报错
var m = 1;
export m;
```

上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二 种写法通过变量 m ，还是直接输出1。 1 只是一个值，不是接口。正确的写法是：

```
// 写法一
export var m = 1;
// 写法二
var m = 1;
export {m};
// 写法三
var n = 1;
export {n as m};
```

`m`是接口，内部的值是1。

另外， export 语句输出的接口**，与其对应的值是动态绑定关系**，即通过该接口， 可以取到模块内部实时的值。

这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在 动态更新。

export 命令可以出现在模块的任何位置，**只要处于模块顶层就可以**。如果 处于块级作用域内，就会报错，下一节的 import 命令也是如此。这是因为处于条 件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。

# import命令

[模块重复导入问题](./模块重复导入.md)

## 模块整体加载

除了指定加载某个输出值，还可以使用整体加载，即用星号（ * ）指定一个对 象，所有输出值都加载在这个对象上面。

```
import * as circle from './circle';
```

模块整体加载所在的那个对象（上例是 circle ），应该是可以静态分析 的，**所以不允许运行时改变**。下面的写法都是不允许的。

```
import * as circle from './circle';
// 下面两行都是不允许的
circle.foo = 'hello';
circle.area = function () {};
```

