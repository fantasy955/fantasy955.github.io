# 事件

## EventObject和 **Event对象

快速看一下两者的属性：

![image-20230529223528453](assets/image-20230529223528453.png)

![image-20230529223602452](assets/image-20230529223602452.png)

简单而言，`EventObject`是对事件的封装，包含更多maxGraph自定义的信息。

`EventMixin`赋予了Graph更多的事件类型，它拿到的是底层的事件，向外传递的却是`EventObject`对象。例如：

![image-20230529224645222](assets/image-20230529224645222.png)

![image-20230529224702443](assets/image-20230529224702443.png)

注意这里的`this`通通指向的是`graph`（类的继承关系：`EventSouce->Graph`）。

`fireEvent`即触发事件，会执行`graph`上的所有事件监听。

那么问题就来到了`this.eventListeners`这边，`Graph`暴露了哪个方法让我们管理这个事件回调数组呢？

添加事件监听的能力在`EventSouce`类中就已经有了（毕竟是事件源对象，理所应当）：

![image-20230529225525349](assets/image-20230529225525349.png)

这就意味着，所有以这种方式注册的事件回调，传入的参数都是sender和eventObject。

那么这个时候，我们大概可以理解为什么需要有`EventObject`对象了。它是`maxGraph`为丰富多样的事件提供的一个统一的事件封装，例如事件类型、触发事件的源对象等。它提供了一组公共方法和属性，用于访问和操作事件信息。

而对于`MouseEvent`，就没有这种待遇了，传入的是`Event`对象（`InternalMouseEvent`）。为什么鼠标事件不需要封装呢，因为我们已经明确知道它是鼠标事件了，不需要通过额外的方式获取信息，例如`tapAndHold`这种经过封装的事件。



## 如何实现`tapAndHold`事件

核心是定时器，因为按压并不会持续触发`mouseDown`或者其他类似的事件，只会触发一次。

因此需要使用定时器判断。

![image-20230529230959136](assets/image-20230529230959136.png)

经过`delay`延时后触发hander。

如果提前松开了，也会将valid置为false。

当再次触发`mouseDown`事件时，需要进行判断：

- 如果没有有效的定时器，则创建一个。
- 如果存在，则判断鼠标选中位置的偏移。



## 如何新增自定义事件

可以看到，`graph.addListener`其实没有对事件名称做限制。但`fireEvent`事件触发时，会遍历所有的回调函数，判断事件名称与回调函数绑定的事件名称是否一致。

因此我们只需要先`addListener`，再在合适的时候`fireEvent`就行了。

一般来说是在基础事件的回调中进行`fire`。



# 图交互

多种高亮状态，如何进行状态的保存和恢复。

- 选中无关区域（非顶点和边），恢复初始化样式，清空所有状态；
- 初始化 -> 选中顶点；
- 初始化 -> 选中边；
- 初始化 -> hover顶点；
- 初始化 -> hover边；

---

- hover边；

- hover边 -> 选中边；

  进行hover高亮前，会保存当前的状态，退出hover后，恢复状态。

  :stars:但是进入选中状态前，会先进入hover状态，为了解决这个问题，我们有两种选择：

  1、取消hover状态；

  2、更新hover的状态缓存（更新为选中样式）；

  第一种方式，取消hover状态，是认为选中状态覆盖hover状态。

  第二种方式，涉及到另一个问题，点击后显示的是hover高亮还是选中高亮，这个问题解决起来比较简单，控制绘制的样式即可。当退出hover后，显示的还是选中的样式。

  :stars:选中边时缓存的状态是永远不变的，即进入hover状态之前的状态。

- （hover边->）选中边 -> 选中边；

  清除选中样式，恢复到选中前状态。

- （hover边->）选中边 -> 选中顶点；

  :stars:顶点的优先级高于边，清除边的选中样式。

- （hover边->）选中边 -> hover边；

  :stars:覆盖和恢复即可。

- （hover边->）选中边 -> hover顶点；

  :stars:覆盖和恢复即可。

---

- hover顶点；

- hover顶点 -> 选中顶点；

- （hover顶点->）选中顶点 ->（hover边->） 选中边；

  :stars:规定了在选中顶点的时候可以选中边，这是一个比较复杂的情况。

  

- （hover顶点->）选中顶点 -> 选中顶点；

- （hover顶点->）选中顶点 -> hover边；

- （hover顶点->）选中顶点 -> hover顶点；

  

  
