# 题目

[两数相除 - 两数相除 - 力扣（LeetCode）](https://leetcode.cn/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/)

[Pow(x, n) - Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/solution/powx-n-by-leetcode-solution/)

# 介绍

在两数相除题目中，要求我们不能使用乘法和除法实现两数相除的取整操作，暴力地使用减法实现会超时：

```c++
#define OVER 0x7fffffff
#define MIN 0x80000000
class Solution {
public:
    int divide(int dividend, int divisor) {
        bool negDividend = dividend < 0;
        bool negDivisor = divisor < 0;
        if (divisor == 1){
            return dividend;
        }
        if (divisor == -1){
            if (dividend == MIN){
                return OVER;
            }
            return -dividend;
        }
        dividend = dividend > 0 ? -dividend : dividend;
        divisor = divisor > 0 ? -divisor : divisor;
        if (divisor == 0){
            return OVER;
        }
        if (divisor == 1){
            return dividend;
        }
        if (divisor == -1){
            if (dividend == MIN){
                return OVER;
            }
            return -dividend;
        }
        int ans = 0;
        int left = dividend;
        while(left <= divisor){
            left = left - divisor;
            if (ans == MIN){
                return OVER;
            }
            ans--;
            if (ans == MIN && negDividend == negDivisor){
                return OVER;
            }
        }
        return negDividend == negDivisor ? -ans : ans;
    }
};
```

# 快速幂

只要$N>=1$, $N$移位后一定会执行`N % 2 == 1`语句块；

`x_contribute`记录的是$x^{2}$, $x^{4}$, $x^{8}$之类的快速值，



```c++
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```



# 快速乘算法

查找备选：**使用移位运算实现二分查找；**

验证备选：**快速乘**

`z & 1`表示是否是奇数

```c++
auto quickAdd = [](int y, int z, int x)
{
    // x 和 y 是负数，z 是正数
    // 需要判断 z * y >= x 是否成立
    int result = 0, add = y;
    while (z)
    {
      	//z % 2 == 1
      // 只会执行一次或两次 （第一次或最后一次）
        if (z & 1) 
        {
            // 需要保证 result + add >= x
            if (result < x - add)
            {
                return false;
            }
            result += add;
        }
        if (z != 1)
        {
            // 需要保证 add + add >= x
            if (add < x - add)
            {
                return false;
            }
            add += add;
        }
        // 不能使用除法
        z >>= 1;
    }
    return true;
};
```

