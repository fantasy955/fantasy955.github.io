# 题目

[641. 设计循环双端队列 - 力扣（LeetCode）](https://leetcode.cn/problems/design-circular-deque/)

> 设计实现双端队列。
>
> 实现 MyCircularDeque 类:
>
> MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。
> boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。
> boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。
> boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。
> boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。
> int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。
> int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。
> boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false  。
> boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。
>
> 示例：
>
> 输入
> ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
> [[3], [1], [2], [3], [4], [], [], [], [4], []]
> 输出
> [null, true, true, true, false, 2, true, true, true, 4]
>
> 解释
> MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
> circularDeque.insertLast(1);			        // 返回 true
> circularDeque.insertLast(2);			        // 返回 true
> circularDeque.insertFront(3);			        // 返回 true
> circularDeque.insertFront(4);			        // 已经满了，返回 false
> circularDeque.getRear();  				// 返回 2
> circularDeque.isFull();				        // 返回 true
> circularDeque.deleteLast();			        // 返回 true
> circularDeque.insertFront(4);			        // 返回 true
> circularDeque.getFront();				// 返回 4

# 解题

首先建立一个容器vector，并在构造函数内初始化容器大小；

使用两个指针（整形变量）`front`，`tail`分布记录头部和尾部位置；

## 关键

定义写入时的规则，指针移动规则：

- 初始化时`front`，`tail`指向0；
- `front`指向的是当前可写入的节点，`tail`指向的是尾部可写入节点的下一个位置，因此写入的位置是`tail-1`。
- `front`写入后`+1`，`tail`写入后-1；

# 代码

```c++
class MyCircularDeque {
private:
    vector<int> myQueue;
    int front;
    int tail;
    int size;
    int maxSize;
public:
    MyCircularDeque(int k) {
        myQueue.resize(k);
        front = 0;
        tail = 0;
        size = 0;
        maxSize = k;
    }
    
    bool insertFront(int value) {
        if (size < maxSize){
            myQueue[front] = value;
            int target = front+1;
            if (target >= maxSize){
                target = 0;
            }
            front = target;
            size++;

            return true;
        }else{
            return false;
        }
    }
    
    bool insertLast(int value) {
        if (size < maxSize){
            int target = tail - 1;
            if (target < 0){
                target = maxSize -1;
            }
            myQueue[target] = value;
            tail = target;
            size++;
            return true;
        }else{
            return false;
        }
    }
    
    bool deleteFront() {
        if (size <= 0){
            return false;
        }else{
            int target = front - 1;
            if (target < 0){
                target = maxSize - 1;
            }
            front = target;
            size--;

            return true;
        }
    }
    
    bool deleteLast() {
        if (size <= 0){
            return false;
        }else{
            int target = tail + 1;
            if (target >= maxSize){
                target = 0;
            }
            tail = target;
            size--;

            return true;
        }
    }
    
    int getFront() {
        if (size <= 0){
            return -1;
        }else{
            int target = front - 1;
            if (target < 0){
                target = maxSize - 1;
            }
            return myQueue[target];
        }
    }
    
    int getRear() {
        if (size <= 0){
            return -1;
        }else{
            return myQueue[tail];
        }
    }
  
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == maxSize;
    }
};

```



# 运行结果

![image-20220815135848831](assets/image-20220815135848831.png)