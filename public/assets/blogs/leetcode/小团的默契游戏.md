# 题目

[美团 2021 届秋季校园招聘笔试真题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/meituan/oxxpwc/)

> 小团从某不知名论坛上突然得到了一个测试默契度的游戏，想和小美玩一次来检验两人的默契程度。游戏规则十分简单，首先给出一个长度为 n 的序列，最大值不超过 m 。
> 小团和小美各自选择一个 [1,m] 之间的整数，设小美选择的是 l ，小团选择的是 r ，我们认为两个人是默契的需要满足以下条件:
>
> l 小于等于 r 。
> 对于序列中的元素 x ，如果 0<x<l ，或 r<x<m+1 ,则 x 按其顺序保留下来，要求保留下来的子序列单调不下降。
> 小团为了表现出与小美最大的默契，因此事先做了功课，他想知道能够使得两人默契的二元组 <l,r> 一共有多少种。
> 我们称一个序列 A 为单调不下降的，当且仅当对于任意的 i>j ，满足 A[i]>=A[j] 。
>
> 作者：美团
> 链接：https://leetcode.cn/leetbook/read/meituan/oxxpwc/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 解题

## 暴力

双重循环，`l`从1开始，`r`从`l`开始；

毫无疑问会超时。

## 二分查找

`r`从`m`逐渐减小到1，对于每个`r`，使用二分法搜寻最大满足条件的`l_max`，对于所有小于`l_max`的`l`，都构成一组解。

### 代码

```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int n, m;
    cin>>n>>m;
    vector<int> nums(n);
    for(int i=0; i<n; i++){
        cin >>nums[i];
    }

    int res = 0;
    for(int r=m; r>=1; r--){
        int l_lower = 1, l_upper = r;
        int count = 0;
        while (l_lower <= l_upper)
        {
            int l = l_lower + ((l_upper-l_lower) >> 1);
            bool flag = true;
            int prem = 0x80000000;
            for(int i=0; i<n; i++){
                if (nums[i] < l || nums[i] > r ){
                    if (nums[i] >= prem){
                        prem = nums[i];
                    }else{
                        flag = false;
                        break;
                    }
                }
            }
            if (flag){
                count = l;
                l_lower = l + 1;
            }else{
                l_upper = l - 1;
            }
        }
        res += count;
        
    }
    cout<<res;

    return 0;
}
```

### 运行结果

![image-20220915160715058](assets/image-20220915160715058.png)

# 总结

对于这种寻找区间的可以固定一个端点，剩下的端点使用高效的方法进行查找。