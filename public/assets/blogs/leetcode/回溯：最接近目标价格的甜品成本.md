# 题目

[1774. 最接近目标价格的甜点成本 - 力扣（Leetcode）](https://leetcode.cn/problems/closest-dessert-cost/)

你打算做甜点，现在需要购买配料。目前共有 `n` 种冰激凌基料和 `m` 种配料可供选购。而制作甜点需要遵循以下几条规则：

- 必须选择 **一种** 冰激凌基料。
- 可以添加 **一种或多种** 配料，也可以不添加任何配料。
- 每种类型的配料 **最多两份** 。

给你以下三个输入：

- `baseCosts` ，一个长度为 `n` 的整数数组，其中每个 `baseCosts[i]` 表示第 `i` 种冰激凌基料的价格。
- `toppingCosts`，一个长度为 `m` 的整数数组，其中每个 `toppingCosts[i]` 表示 **一份** 第 `i` 种冰激凌配料的价格。
- `target` ，一个整数，表示你制作甜点的目标价格。

你希望自己做的甜点总成本尽可能接近目标价格 `target` 。

返回最接近 `target` 的甜点成本。如果有多种方案，返回 **成本相对较低** 的一种。

# 分析

刚开始看时，感觉跟01背包问题很像。

但是在01背包问题中，我们追求的是价值最大，因此使用了一个二维数组`a[i][j]`，表示拿到第i个物体时，空间为`j`所能装的最大价值总和。

`w[i]`第i个物品的体积；

`v[i]`价值；

V背包总大小；

```c++
for (int i = 1; i <= n; i++)  // 物品编号从1到n
{
	for (int j = V; j >= 0; j--) 
	{
		if (j >= w[i])
		{
			f[i][j] = max(f[i - 1][j], // 不拿这个物品
                    f[i - 1][j - w[i]] + v[i]);  // 放入背包，在
		}
		else
		{
			f[i][j] = f[i - 1][j];
		}
	}
}
```

**不放入背包时**:第i次决策后的最大价值和第i-1次决策时候的价值是一样的（还是原来的那些物体，没多没少）。
**放入背包时**:第i次决策后的价值为 **第i-1次决策时候的价值** 加上 **当前物体的价值v[j]**。**物体放入背包后会使背包容量变为 j** ，**即没放物体之前背包的容量为j - w[i]**。

## 区别

在本题中，冰淇淋基料可以看成外部循环，无上大雅，可以视为在放入背包前，需要放一个最重要的东西。

**第一点区别是，构造状态矩阵**。

01背包中，我们使用总和。背包问题是背包体积和价值的二元问题。

而本题只是价值的一元问题。因此矩阵是一维的，为了记录配置数量，`f[i][j]`表示加`j`份第`i`个配料的价格总和。

这也意味着我们不能写出状态转移方程。

**确定参数数量级后**（n和m小于10），考虑使用回溯的方法解题。

# 答案

```js
var closestCost = function (baseCosts, toppingCosts, target) {
    let res = baseCosts[0];
    for (const base of baseCosts) {
        if (base === target) {
            res = target;
            break;
        }
        let tmpRes = doDFS(base, target, toppingCosts, res);
        if (tmpRes === target){
            res = target;
            break;
        }
        if (Math.abs(tmpRes-target) < Math.abs(res-target)){
            res = tmpRes;
        }else if(Math.abs(tmpRes-target) === Math.abs(res-target)){
            res = Math.min(res, tmpRes);
        }
        // console.log('**************');
    }
    return res;
};

function doDFS(base, target, toppingCosts, res) {
    let maxCost = res;
    function dfs(sum, toppingCosts, target, i){
        if (i === toppingCosts.length){
            if (Math.abs(sum-target) < Math.abs(maxCost-target)){
                maxCost = sum;
            }else if(Math.abs(sum-target) === Math.abs(maxCost-target)){
                maxCost = Math.min(sum, maxCost);
            }
            // console.log('sum:', sum);
            // console.log('目前答案:', maxCost);
            return;
        }
        let count = 0;
        // 如果加料数量没有限制的话，
        // 只需要添加条件：当前sum与target的差值 小于 当前答案与target的差值
        // 这个条件不行，例如target是18， 已经确定的一个答案是15，那么差值是3
        // 如果一个价格为2的配料，意味着用于不会添加该配料。
        // 因此只有当答案大于target，并且差值大于 当前答案与target的差值时，才退出
        while (count <= 2) {
            // console.log('i:',i, ' count:', count);
            dfs(sum + toppingCosts[i] * count, toppingCosts, target, i+1);
            count++;
        }
    }
    dfs(base, toppingCosts, target, 0);
    return maxCost;
}
```

# 反思

- 没有很快想到回溯的解题办法。

- 刚开始没看清题目（以为配料可以无限添加），同时while循环的退出条件没有想清楚，浪费了很多时间。

- if语句内没有写return，导致函数返回undefined。（最开始使用`return dfs(base, toppingCosts, target, 0);`，不是在最后返回外部变量）

  

