# 复习c++栈、队列操作

## 栈

- 取栈顶元素

```
stack.top()
```

- 弹出栈顶元素

```
stack.pop()
```

- 插入

```
queue.push()
```

## 队列

尾部插入，头部弹出

- 取队首（头部）元素

```
queue.front()
```

- 取队尾元素

```
queue.back()
```

- 弹出元素

```
queue.pop()
```

- 插入

```
queue.push()
```

# 题目

[946. 验证栈序列 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-stack-sequences/submissions/)

> 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。
>
>  
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/validate-stack-sequences
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

即给定一个序列输入序列和弹出序列，我们指导入栈顺序，但不知道什么时候出栈；

需要判断出栈顺序是否合法。

在栈中，后进入的元素先出来，因此，每个出栈的元素，一定位于栈的顶部；

我们使用一个辅助栈，将输入序列压入栈中，**当栈顶元素等于出栈元素时，其一定要出栈**，出栈序列的指针+1；

# 代码

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        // unordered_map<int, int> numInStack;
        stack<int> helper;
        int n = pushed.size();
        if (n <= 1){
            return true;
        }
        int j = 0;
        int top;
        for(int i=0; i<n; i++){
            // numInStack[pushed[i]] += 1;
            helper.push(pushed[i]);
            while(helper.size() >0){
                if (helper.top() == popped[j]){
                    helper.pop();
                    j++;
                }else{
                    break;
                }
            }
        }
        return helper.size() == 0;
    }
};
```

# 结果

![image-20220831095324875](assets/image-20220831095324875.png)

# 官方题解

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int n = pushed.size();
        for (int i = 0, j = 0; i < n; i++) {
            st.emplace(pushed[i]);
            while (!st.empty() && st.top() == popped[j]) {
                st.pop();
                j++;
            }
        }
        return st.empty();
    }
};
```

