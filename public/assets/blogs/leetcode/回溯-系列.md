## **BM74** **数字字符串转化成IP地址**

- [数字字符串转化成IP地址_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e?tpId=295&tqId=653&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

回溯解决时，在某一层，不要依赖之前的状态。

```js
function restoreIpAddresses(s) {
    let res = [];
    s = s.split("").map((c) => c.charCodeAt() - "0".charCodeAt());
    const n = s.length;
    function dfs(ip, i) {
        console.log(ip);
        if (ip.length === 4) {
            if (i === n) {
                res.push(Array.from(ip));
                return;
            }
        }
        if (ip.length > 4) {
            return;
        }

        let cur = 0;
        for(let j=i; j<n; j++){
            cur = cur * 10 + s[j];
            if (cur <= 255 && (j===i || s[i] !== 0)){
              // 在这一层，把所有可能的组合全部遍历
                ip.push(cur);
                dfs(ip, j+1);
                ip.pop();
            }
        }
    }
    dfs([], 0);
    res = res.map((ip) => ip.join("."));
    console.log(new Set(res));
    return Array.from(new Set(res));
    // return res;
}

restoreIpAddresses('101023')

```

**反面教材**

```js
/**
 *
 * @param s string字符串
 * @return string字符串一维数组
 */
function restoreIpAddresses(s) {
    let res = [];
    s = s.split("").map((c) => c.charCodeAt() - "0".charCodeAt());
    const n = s.length;
    function func(IP, i) {
        const current = IP[IP.length - 1];
        console.log(IP);
        if (IP.length === 4) {
            if (i === n) {
                res.push(Array.from(IP));
                return;
            }
        }
        if (IP.length > 4) {
            return;
        }
        // console.log(IP, i);

      
        if (current === 0) {
            // 无法继续添加数字
            IP.push(s[i]);
            func(IP, i + 1);
        } else {
            let temp = current;
            for (let j = i; j < n; j++) {
                temp = temp * 10 + s[j];
                if (temp <= 255) {
                  // 这里是想将这一层的数值最为temp
									// 但是进入下一层时没有添加起始符
                    IP[IP.length - 1] = temp;
                    func(IP, j + 1);
                    temp = temp * 10 + s[j];
                } else {
                    break;
                }
            }
            if (i < n) {
                IP[IP.length - 1] = current;
                IP.push(s[i]);
                func(IP, i + 1);
                IP.pop();
            }
        }
    }
   // 这里想想影响下一层的状态
   // 添加了一个起始符
    func([s[0]], 1);
    res = res.map((ip) => ip.join("."));
    console.log(new Set(res));
    return Array.from(new Set(res));
    // return res;
}
module.exports = {
    restoreIpAddresses: restoreIpAddresses,
};
```

