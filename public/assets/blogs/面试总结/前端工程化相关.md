## 如何搭建前端脚手架(CLI)

CLI即命令行界面，也就是一个命令行工具。

脚手架可以创建项目时的重复性操作，统一开发风格（eslint和stylelint），规范项目目录，让开发更专注于业务。

## TreeShaking

TreeShaking是一种减小代码体积的技术，它的原理是检测EM模块中哪些被导出的值没有被使用，这些没有被使用的值不会出现在打包的产物中。

在实际使用中，Treeshaking通常与ES6的模块化机制结合使用。**因为ES6的模块化机制是静态的，可以在编译时分析出依赖关系**，从而进行剪枝操作。对于其他的代码（如CommonJS、AMD等），因为它们的依赖关系是动态的，无法在编译时确定，所以无法进行Treeshaking优化。

Treeshaking的实现需要满足两个条件：代码必须是纯函数，且不会产生副作用。如果代码中存在副作用，例如在函数内部修改全局变量，那么就无法进行Treeshaking。另外，Treeshaking的实现也需要支持Tree Shaking的标准。在Webpack中，需要使用支持Tree Shaking标准的模块打包器，如Webpack 2或更高版本，并且需要开启`production`模式，才能实现Treeshaking优化。

## webpack

在Webpack的运行过程中，每次执行Webpack命令都会创建一个新的Compiler实例。一个Compiler实例负责一次新的编译过程，并且会生成一个或多个Compilation实例。

Compilation对象是Webpack在每次构建中创建的，**它包含了当前的模块资源、编译生成的资源、变化的文件等信息**。在Compilation对象中，Webpack会将模块解析后的信息存放在模块映射表（module map）中，方便后续处理。

在Webpack中，一个Compilation对象只负责一次编译过程中的**资源的编译和输出**。每次编译都会生成一个新的Compilation对象，Webpack会在内存中保存最近一次的Compilation对象，以便后续的增量编译。

## Vite

- 将模块分为依赖和源码，依赖是开发时不会改动的纯JavaScript。源码一般不是直接的JS文件。
- 依赖存在多种模块化格式，使用ESBuild预构建**依赖**，esbuild使用go编写，速度更快。
- 基于ES模块化，提升开发过程的体验，由于无需构建整个应用，开发服务器启动更快，热模块替换速度更快。以原生ESM方式提供源码，让浏览器进行模块的导入，Vite 只需要在浏览器请求源码时进行转换并按需提供源码。

> 为什么生产环境还是要打包？

主要是为了优化性能。由于模块的嵌套嵌入，ES模块化会造成额外的网络往返。

打包可以进行tree-shaking、懒加载和 chunk 分割。

> 为什么不用esbuild打包

esbuild无法与我们经常用到其他前端工具或框架进行配合，例如eslint和postcss。esbuild无法进行代码分割和CSS处理。	

## file-loader和url-loader

[`file-loader` 和 `url-loader` 都是用于处理文件的 webpack loader。它们的主要区别在于：当文件大小小于设定的 `limit` 时，`url-loader` 会将文件转换为 base64 编码的 Data URL，而 `file-loader` 则返回文件的 public URL。](https://blog.csdn.net/WEB_YH/article/details/79325182)[1](https://blog.csdn.net/WEB_YH/article/details/79325182)[2](https://blog.csdn.net/wu_xianqiang/article/details/104558773)

简单来说，当**你需要将小文件内联到代码中以减少 HTTP 请求时**，可以使用 `url-loader`；否则可以使用 `file-loader`。

## git怎么解决代码冲突

处理git代码冲突有几种方法。你可以使用命令行来解决冲突，首先需要使用 `git checkout` 切换到冲突的分支，然后使用 `git mergetool` 或 `git diff` 来比较冲突的文件[1](https://www.zhihu.com/question/580699943)。你也可以在代码编辑器中打开冲突的文件，手动比较并合并两个版本[1](https://www.zhihu.com/question/580699943)。

**提交到远程仓库出现冲突**

1. 首先，运行 `git fetch` 命令来获取远程仓库的最新更改。
2. 然后，运行 `git merge` 命令来合并远程仓库的更改。
3. 在合并过程中，如果出现冲突，Git会提示您解决冲突。您可以通过编辑冲突文件来手动解决冲突。
4. 解决完所有冲突后，运行 `git add` 命令来将解决冲突后的文件添加到暂存区。
5. 最后，运行 `git commit` 命令来提交解决冲突后的更改。

`git fetch` 命令用于从远程仓库获取最新的更改，但不会将这些更改合并到当前分支中。这样，您可以先查看远程仓库的更改，然后再决定是否将这些更改合并到当前分支中。

当您运行 `git fetch` 命令时，它会获取远程仓库中所有分支的最新提交，并更新本地仓库中对应的远程跟踪分支。例如，如果您的本地仓库有一个名为 `origin/master` 的远程跟踪分支，那么运行 `git fetch` 命令后，该分支将被更新为远程仓库中 `master` 分支的最新状态。

`git fetch` 命令不会创建新的本地分支。它只会更新本地仓库中已有的远程跟踪分支，以便它们与远程仓库中对应的分支保持同步。

如果想在本地创建一个新分支来跟踪远程仓库中的某个分支，可以使用 `git checkout` 命令。例如，要创建一个名为 `mybranch` 的新本地分支来跟踪远程仓库中的 `master` 分支，可以运行 `git checkout -b mybranch origin/master` 命令。

使用 `git branch -vv` 命令来查看本地分支当前追踪的远程分支。该命令会显示本地仓库中所有分支的列表，以及每个分支当前追踪的远程分支（如果有的话）。

如果您想更改本地分支当前追踪的远程分支，可以使用 `git branch` 命令的 `-u` 或 `--set-upstream-to` 选项。

例如，假设您的本地仓库中有一个名为 `mybranch` 的分支，它当前追踪远程仓库中的 `origin/master` 分支。如果您想将其更改为追踪远程仓库中的 `origin/develop` 分支，可以运行以下命令：

```shell
git branch -u origin/develop mybranch
```

或者，如果您当前已经切换到了 `mybranch` 分支，可以省略分支名称，直接运行：

```shell
git branch -u origin/develop
```

以上命令会将本地 `mybranch` 分支的上游分支更改为 `origin/develop`。

## webpack生命周期

webpack是基于tapable让开发者能够动态注册回调形成插件机制。

Tapable支持同步回调和异步回调。

在webpack的打包过程，会创建两个关键的对象compiler和compilation。

在webpack中，**compiler** 对象是编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出。而 **compilation** 对象是单次编辑过程的管理器，比如当watch = true时，运行过程中只有一个compiler，但每次文件变更触发重新编译时，都会创建一个新的compilation对象[1](https://bing.com/search?q=webpack+compiler和compilation区别)。

简单来说，compiler对象负责管理整个webpack构建过程，而compilation对象负责管理单次编辑过程。

`Compiler` 模块是 webpack 的主要引擎，它通过 [CLI](https://www.webpackjs.com/api/cli) 或者 [Node API](https://www.webpackjs.com/api/node) 传递的所有选项创建出一个 compilation 实例。

`compilation` 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。 它会对应用程序的依赖图中所有模块， 进行字面上的编译(literal compilation)。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。

要注册`compilation`的生命周期回调，需要在`compiler`的`thisCompilation`回调内部注册，因为这个时候才创建了`compilation`对象。
