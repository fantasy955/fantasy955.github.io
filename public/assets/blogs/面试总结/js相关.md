## 0.1+0.2 !== 0.3

关键在于使用二进制表示浮点数。0.1和0.2在二进制中是无限循环的。

[IEEE754是一个浮点数标准，它规定了浮点数的格式和运算方法](https://segmentfault.com/a/1190000024578628)[1](https://segmentfault.com/a/1190000024578628)[2](https://baike.baidu.com/item/IEEE 754/3869922)[3](https://en.wikipedia.org/wiki/IEEE_754)[。浮点数是用来表示实数的一种近似值，它由符号位，阶码和尾数三部分组成](https://segmentfault.com/a/1190000024578628)[1](https://segmentfault.com/a/1190000024578628)[4](https://blog.csdn.net/weixin_47713503/article/details/108699001)。浮点数的误差主要有两个原因：

- [进制问题。由于计算机使用二进制来存储和运算浮点数，而有些十进制的小数在二进制中不能精确表示，比如0.1，0.2等，所以在转换的过程中会产生截断误差](https://blog.csdn.net/cluster1893/article/details/80757724)[5](https://blog.csdn.net/cluster1893/article/details/80757724)[6](https://www.zhihu.com/question/380574329)。这种误差是不可避免的，只能通过增加浮点数的位数来减小误差的影响。
- [精度问题。由于浮点数的尾数部分有限，所以它不能表示所有的实数，只能表示一部分有限的实数。这就意味着浮点数的精度是有限的，不能无限接近真实值。浮点数的精度由尾数的位数决定，比如float型浮点数的尾数部分有23位，换算成十进制就是223=8388608，所以十进制精度只有6~7位；double型浮点数的尾数部分有52位，换算成十进制就是252=4503599627370496，所以十进制精度只有15~16位](https://www.zhihu.com/question/380574329)[6](https://www.zhihu.com/question/380574329)。这种误差在浮点数的运算中会累积，可能导致最终结果的偏差。

C++中0.1+0.2的运算结果并不一定是正确的，这取决于你使用的是什么类型的变量来存储和计算这两个数¹⁴⁶。如果你使用的是整型变量（int），那么0.1和0.2会被截断为0，0+0的结果当然是0；如果你使用的是浮点型变量（float或double），那么0.1和0.2会被转换为二进制的近似值，然后进行加法运算，最后再转换为十进制的近似值，这个过程中可能会产生误差¹²³。例如，如果你使用float型变量，那么0.1+0.2的结果可能是0.30000001或者0.29999999，而不是0.3；如果你使用double型变量，那么0.1+0.2的结果可能是0.30000000000000004或者0.29999999999999998，而不是0.3。这是因为float和double的精度是有限的，不能无限接近真实值¹⁴⁶。如果你想得到精确的结果，你可以使用其他的数据类型，比如分数或者高精度数，或者使用一些数学库或者工具来处理浮点数的误差³。

源: 与必应的对话， 2023/2/15

(1) C++ 运算符 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-operators.html 访问时间 2023/2/15.
(2) 【C++】如何使程序的除法运算结果变为小数？_小鹿Madoka的博客-CSDN博客_c++中除法怎么带小数点. https://blog.csdn.net/weixin_37706349/article/details/118017767 访问时间 2023/2/15.
(3) C++ 变量类型 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-variable-types.html 访问时间 2023/2/15.
(4) C++中0与1互转的四种方法_SHI和远方的博客-CSDN博客_c++怎么把1变成0 0 变成1. https://blog.csdn.net/Flysa_1/article/details/109339433 访问时间 2023/2/15.
(5) C++位运算符（&、 | 、^）_Wonder-King的博客-CSDN博客_c++. https://blog.csdn.net/qq_42391248/article/details/84790152 访问时间 2023/2/15.
(6) C++ 数组 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-arrays.html 访问时间 2023/2/15.

---

## 对事件循环的理解

js是单线程的，一个时间只能做一件事，但js的执行并不是阻塞的，让js不是阻塞执行的方法就是事件循环。js中的任务分为宏任务和微任务，

### 参考资料

- [[前端进阶\] - 搞懂浏览器进程和线程 - 掘金 (juejin.cn)](https://juejin.cn/post/7053974933931556900)
- [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903553795014663)

---

## 高阶函数、纯函数和函数柯里化

- 高阶函数是指可以接收另一个函数作为参数的函数。

- 纯函数是指不依赖于外部变量，不修改程序状态，不产生副作用，对于相同的输入，总会产生相同的输出。
  纯函数避免副作用的方法是不依赖于外部变量、状态或输入输出设备，我们将其所需要的依赖作为参数传递给他。那么一些带来副作用的操作，也需要作为参数传递给他。
- 函数柯里化是把接收多个参数的函数变换成接收一个单一参数的函数，并且这个接收单一参数的新函数。函数柯里化的作用主要是参数复用和动态创建函数。参数复用避免重复传入相同的参数，动态创建函数可以实现更灵活的编程。
  例如`jwa`库中通过传入的参数生成一个加密函数。

## 防抖和节流

防抖和阶段都是使用高阶函数，对传入的函数进行处理，返回一个新函数。

防抖是要在一段时间后触发，在这一段时间内重复触发的话会取消之前的触发请求，即只执行最新的请求；例如在搜索框内输入内容自动执行搜索。

节流是触发后立即执行，但是一段时间内不能再次触发；例如购物网站的添加商品按钮。

---

## 几种继承方式总结

- 原型链继承将父类实例作为子类的原型，会导致所有父类属性被子类对象所共享，包括父类构造函数类定义的属性。
- 盗用构造函数继承是在子类的构造函数中执行父类的构造函数，这一步通过call或apply函数进行，因为要将父类构造函数中的this指针改为子类对象；这种方法会丢失父类原型上的属性和方法。
- 组合式继承是综合原型继承和盗用构造函数继承，由于子类对象上添加了父类属性，屏蔽了对原型上相同名称属性的访问。
- 原型继承是基于`Object.create`方法，创建一个新对象，并将新对象的原型设为这个函数接收的对象，当然不借助这个方法也能达成相同的目的。寄生式继承与该方法相似，只是会有手动创建构造函数的过程，将新构造函数的原型设为接收到的对象，返回新构造函数创建的实例，给实例添加新的方法。
- 寄生式组合继承被称为经典的伪继承，它利用原型式继承得到一个新**原型对象**，这个原型对象的隐式原型指向父类原型，原型上有constructor属性，指向构造函数，一般而言，它指向自身（`test.prototype.constructor === test // ture`），但是我们在这个新的原型对象上添加`constructor`属性，覆盖父类原型上的构造函数，而去执行子类的构造函数。最终结果是我们只继承了父类原型，在子类的构造函数中执行了父类构造函数。继承了父类的所有属性和方法，并且没有执行多余的代码。相比组合式继承，它是用一个新的实例保存了父类原型，而组合式继承是直接使用父类实例保存与父类原型的联系。

---

