## 0.1+0.2 !== 0.3

关键在于使用二进制表示浮点数。0.1和0.2在二进制中是无限循环的。

[IEEE754是一个浮点数标准，它规定了浮点数的格式和运算方法](https://segmentfault.com/a/1190000024578628)[1](https://segmentfault.com/a/1190000024578628)[2](https://baike.baidu.com/item/IEEE 754/3869922)[3](https://en.wikipedia.org/wiki/IEEE_754)[。浮点数是用来表示实数的一种近似值，它由符号位，阶码和尾数三部分组成](https://segmentfault.com/a/1190000024578628)[1](https://segmentfault.com/a/1190000024578628)[4](https://blog.csdn.net/weixin_47713503/article/details/108699001)。浮点数的误差主要有两个原因：

- [进制问题。由于计算机使用二进制来存储和运算浮点数，而有些十进制的小数在二进制中不能精确表示，比如0.1，0.2等，所以在转换的过程中会产生截断误差](https://blog.csdn.net/cluster1893/article/details/80757724)[5](https://blog.csdn.net/cluster1893/article/details/80757724)[6](https://www.zhihu.com/question/380574329)。这种误差是不可避免的，只能通过增加浮点数的位数来减小误差的影响。
- [精度问题。由于浮点数的尾数部分有限，所以它不能表示所有的实数，只能表示一部分有限的实数。这就意味着浮点数的精度是有限的，不能无限接近真实值。浮点数的精度由尾数的位数决定，比如float型浮点数的尾数部分有23位，换算成十进制就是223=8388608，所以十进制精度只有6~7位；double型浮点数的尾数部分有52位，换算成十进制就是252=4503599627370496，所以十进制精度只有15~16位](https://www.zhihu.com/question/380574329)[6](https://www.zhihu.com/question/380574329)。这种误差在浮点数的运算中会累积，可能导致最终结果的偏差。

C++中0.1+0.2的运算结果并不一定是正确的，这取决于你使用的是什么类型的变量来存储和计算这两个数¹⁴⁶。如果你使用的是整型变量（int），那么0.1和0.2会被截断为0，0+0的结果当然是0；如果你使用的是浮点型变量（float或double），那么0.1和0.2会被转换为二进制的近似值，然后进行加法运算，最后再转换为十进制的近似值，这个过程中可能会产生误差¹²³。例如，如果你使用float型变量，那么0.1+0.2的结果可能是0.30000001或者0.29999999，而不是0.3；如果你使用double型变量，那么0.1+0.2的结果可能是0.30000000000000004或者0.29999999999999998，而不是0.3。这是因为float和double的精度是有限的，不能无限接近真实值¹⁴⁶。如果你想得到精确的结果，你可以使用其他的数据类型，比如分数或者高精度数，或者使用一些数学库或者工具来处理浮点数的误差³。

源: 与必应的对话， 2023/2/15

(1) C++ 运算符 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-operators.html 访问时间 2023/2/15.
(2) 【C++】如何使程序的除法运算结果变为小数？_小鹿Madoka的博客-CSDN博客_c++中除法怎么带小数点. https://blog.csdn.net/weixin_37706349/article/details/118017767 访问时间 2023/2/15.
(3) C++ 变量类型 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-variable-types.html 访问时间 2023/2/15.
(4) C++中0与1互转的四种方法_SHI和远方的博客-CSDN博客_c++怎么把1变成0 0 变成1. https://blog.csdn.net/Flysa_1/article/details/109339433 访问时间 2023/2/15.
(5) C++位运算符（&、 | 、^）_Wonder-King的博客-CSDN博客_c++. https://blog.csdn.net/qq_42391248/article/details/84790152 访问时间 2023/2/15.
(6) C++ 数组 | 菜鸟教程. https://www.runoob.com/cplusplus/cpp-arrays.html 访问时间 2023/2/15.

---

## 对事件循环的理解

js是单线程的，一个时间只能做一件事，但js的执行并不是阻塞的，让js不是阻塞执行的方法就是事件循环。js中的任务分为宏任务和微任。

当宏任务队列中有多个任务时，每次只会将一个宏任务放入执行栈中执行，当它执行完后，会先执行所有微任务队列中的任务，再进行下一个宏任务。

### 参考资料

- [[前端进阶\] - 搞懂浏览器进程和线程 - 掘金 (juejin.cn)](https://juejin.cn/post/7053974933931556900)
- [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903553795014663)

---

## 高阶函数、纯函数和函数柯里化

- 高阶函数是指可以接收另一个函数作为参数的函数，或者函数的返回值是一个函数。

- 纯函数是指不依赖于外部变量，不修改程序状态，不产生副作用，对于相同的输入，总会产生相同的输出。
  纯函数避免副作用的方法是不依赖于外部变量、状态或输入输出设备，我们将其所需要的依赖作为参数传递给他。那么一些带来副作用的操作，也需要作为参数传递给他。
- 函数柯里化是把接收多个参数的函数变换成**接收一个单一参数的函数**，并且返回这个接收单一参数的新函数。函数柯里化的作用主要是参数复用和动态创建函数。参数复用避免重复传入相同的参数，动态创建函数可以实现更灵活的编程。
  例如`jwa`库中通过传入的参数生成一个加密函数。
- 在实际使用过程中，往往同时使用高阶函数和函数柯里化，例如一个去抖函数。

## 防抖和节流

防抖和阶段都是使用高阶函数，对传入的函数进行处理，返回一个新函数。

防抖是要在一段时间后触发，在这一段时间内重复触发的话会取消之前的触发请求，即只执行最新的请求；例如在搜索框内输入内容自动执行搜索。

节流是触发后立即执行，但是一段时间内不能再次触发；例如购物网站的添加商品按钮。

---

## 几种继承方式总结

- 原型链继承将父类实例作为子类的原型，会导致所有父类属性被子类对象所共享，包括父类构造函数类定义的属性。
- 盗用构造函数继承是在子类的构造函数中执行父类的构造函数，这一步通过call或apply函数进行，因为要将父类构造函数中的this指针改为子类对象；这种方法会丢失父类原型上的属性和方法。
- 组合式继承是综合原型继承和盗用构造函数继承，由于子类对象上添加了父类属性，屏蔽了对原型上相同名称属性的访问。
- 原型继承是基于`Object.create`方法，创建一个新对象，并将新对象的原型设为这个函数接收的对象，当然不借助这个方法也能达成相同的目的。寄生式继承与该方法相似，只是会有手动创建构造函数的过程，将新构造函数的原型设为接收到的对象，返回新构造函数创建的实例，给实例添加新的方法。
- 寄生式组合继承被称为经典的伪继承，它利用原型式继承得到一个新**原型对象**，这个原型对象的隐式原型指向父类原型，原型上有constructor属性，指向构造函数，一般而言，它指向自身（`test.prototype.constructor === test // ture`），但是我们在这个新的原型对象上添加`constructor`属性，覆盖父类原型上的构造函数，而去执行子类的构造函数。最终结果是我们只继承了父类原型，在子类的构造函数中执行了父类构造函数。继承了父类的所有属性和方法，并且没有执行多余的代码。相比组合式继承，它是用一个新的实例保存了父类原型，而组合式继承是直接使用父类实例保存与父类原型的联系。

---

## V8引擎

### 垃圾回收

栈中的数据通过函数栈指针的变化被自动释放，这个释放并不是真正的释放，只是栈顶指针下移了。

JavaScript中的对象都存储在堆上，垃圾回收主要是回收堆上那些不再被使用的对象。V8引擎将堆分为不同的代，不同代内对象的生命周期长度不同。分代基于的原理是，一般来说新创建的对象生命周期不会太长，而一直存在的对象一般具有很长的生命周期。如果不分代，每次进行标记-清理时，就需要遍历所有内存中的对象，而其中生命周期长的对象在每次回收时都会被遍历，我们希望更少地管理那些生命周期比较长的对象。

分代主要是分为新生代和老生代，新创建的对象会保存在新生代中。**这些对象往往在其创建后很快就变得无用了**。为了更快地回收这些对象，V8采用了Scavenger算法，该算法专门针对新生代设计，将**新生代内存分为两个区域：From空间和To空间**，这两个空间的大小相同，因为要考虑到需要将From空间的所有对象复制到To空间。**当From空间被填满时**，V8会将其中的存活对象复制到To空间中，并清空From空间。这个过程称为Scavenge，可以快速且高效地回收大量的短期生命周期对象。存活对象使用标记算法识别。

**当一个对象在新生代中经过多次垃圾回收后，如果仍然存活，就会被转移到老生代中**。对象从新生代转移到老生代的过程称为晋升（promotion）。晋升的条件通常是对象已经经**历过一定次数的Scavenge过程**，并且仍然存活。被晋升到老生代中的对象将不再参与新生代的垃圾回收，而是由老生代的垃圾回收器来管理。

老生代包含的是生命周期较长的对象，因此无法使用新生代的Scavenger算法进行垃圾回收。针对老生代的垃圾回收，V8采用了标记清除和标记压缩两种算法，它们能够更高效地回收较长生命周期的对象。同时，V8还使用了增量标记和并发标记等技术来避免在垃圾回收过程中对JavaScript执行造成过多的中断。

标记过程首先找到内存中所有被引用的对象，并做标记，之后遍历整个堆，将没有被标记的对象的内存进行回收，回收方式一般是将内存标记为可用。

---

## setTimeout和requestAnimationFrame实现动画效果的区别

`setTimeout`和`requestAnimationFrame`都可以用来实现动画效果，但它们之间有一些区别。

1. 刷新率

浏览器每秒钟会进行多次屏幕刷新，即重绘，来显示页面的变化和动画效果。这个刷新率通常被称为“屏幕刷新率”、“帧率”或“FPS”（Frames Per Second）。

`setTimeout`的刷新率是固定的，通常为每秒60次。这意味着，无论机器的性能如何，动画都会以相同的速度运行。而`requestAnimationFrame`的**刷新率是浏览器的刷新率，通常为每秒60次，但在某些高刷新率屏幕上可能会更高。**这使得`requestAnimationFrame`更加流畅和自然。

1. 可靠性

`requestAnimationFrame`是浏览器提供的原生API，可以保证每一帧的渲染时机都是最优的，同时可以避免多个动画同时运行时出现的问题。而`setTimeout`是JavaScript自带的函数，其执行时间不一定是最优的，可能会出现闪烁或卡顿等问题。

1. 性能

`requestAnimationFrame`的性能通常比`setTimeout`更好，因为`requestAnimationFrame`会在下一次浏览器渲染之前调用回调函数，这样可以最大程度地减少了浏览器的重绘次数，从而减少了CPU和GPU的占用。

因此，一般来说，建议使用`requestAnimationFrame`来实现动画效果，因为它提供了更高的性能和更流畅的动画效果。当然，如果要实现的动画效果非常简单，或者需要在某些情况下控制动画的速度，`setTimeout`也是一个不错的选择。

---

## 上下文、作用域、函数执行栈

- 上下文（Context）：JavaScript 代码执行时所处的环境。每当代码执行到一个新的可执行块（如函数、模块等）时，都会进入一个新的上下文。一个上下文可以包含多个作用域。每个上下文都有自己的变量对象，用来存储在该上下文中定义的变量和函数。
- 作用域（Scope）：**指在当前上下文中可访问的变量和函数的集合**。JavaScript 使用**词法作用域**，**即函数的作用域是在函数定义时确定的，而不是在函数调用时**。一个变量的作用域取决于它在代码中定义的位置。当在一个上下文中使用一个变量时，JavaScript 引擎会首先在该上下文的变量对象中查找该变量，如果找不到，则会到父级作用域中查找，直到找到该变量为止。
- 执行栈（Execution Context Stack）：JavaScript 引擎会维护一个执行栈，**用来存储当前正在执行的上下文**。当代码执行到一个新的可执行块时，会创建一个新的上下文并将其推入执行栈中，当该块执行完毕后**，该上下文会被弹出执行栈，控制权会回到上一个上下文中继续执行**。

JavaScript 中的事件循环机制是指在单线程的 JavaScript 运行时中，为了处理异步任务，而采用的一种事件循环的机制。它通过监听任务队列中的任务，来实现异步任务的执行。

**事件循环机制与上下文、作用域和执行栈有以下关系**：

1. 上下文：JavaScript 中的上下文是指当前代码执行的环境，包括全局上下文和函数上下文。事件循环机制中的任务执行，都是在某个上下文中执行的。
2. 作用域：JavaScript 中的作用域是指当前执行代码的变量可访问的范围。事件循环机制中的任务执行，也是在其所在的作用域中执行的。
3. 执行栈：JavaScript 中的执行栈是指代码执行的顺序。事件循环机制中，任务首先进入任务队列，然后再由事件循环机制从任务队列中取出任务，放到执行栈中执行。

**JavaScript 的事件循环机制主要分为以下几个阶段：**

1. 宏任务：在事件循环的每一次循环中，只会执行一个宏任务。宏任务包括 **script 脚本执行**、`setTimeout`、`setInterval`、`setImmediate`、`I/O `操作等。
2. 微任务：在宏任务执行完成后，会依次执行当前所有微任务。微任务包括` Promise.then`、`Promise.catch`、`Promise.finally`、`MutationObserver`、`process.nextTick` 等。
3. 渲染：当所有微任务执行完成后，如果当前需要更新页面，则进行页面的渲染。

总的来说，事件循环机制通过监听任务队列中的任务，实现了异步任务的执行，使得 JavaScript 在单线程运行时也能够处理异步操作。同时，上下文、作用域和执行栈等概念，也是事件循环机制的重要组成部分。

---

## this指针

在 JavaScript 中，this 关键字是一个特殊的对象引用，它指向当前执行上下文的对象。在函数中，this 引用的是该函数被调用时所在的对象。在全局上下文中，this 引用的是全局对象，如 window 或者 global。

在**普通函数中**，this 的指向是在运行时确定的，它取决于调用该函数的方式。如果函数作为对象的方法调用，this 将指向该对象；如果函数作为普通函数调用，则 this 将指向全局对象。

在**箭头函数中**，this 的指向是在定义时确定的，它取决于箭头函数所在的上下文。箭头函数的 this 始终指向定义该函数的父级上下文中的 this。

此外，还有一些情况下，this 的指向可能会发生变化，比如**在事件处理程序**中，this 将引用触发事件的元素。**在 JavaScript 的模块中**，this 指向 undefined，因为模块中的代码运行在独立的作用域中。在**严格模式**下，this 的指向会更加严格。在**全局环境中，严格模式下的 this 始终为 undefined**；在函数内部，如果没有明确指定 this 的值，严格模式下的 this 为 undefined。

在 JavaScript 的严格模式中，如果没有明确指定 this 的值，this 就会被设置为 undefined。这种情况下，如果想要使用 this 指针，有以下两种方法：

1. 使用 Function.prototype.call() 或 Function.prototype.apply() 明确指定 this 指向。这两个方法的第一个参数即为 this 指向的对象。
2. 使用箭头函数。箭头函数没有自己的 this 值，箭头函数内部的 this 值继承自外部的作用域。因此，在箭头函数中使用 this，其指向的就是外部函数的 this 值。**在箭头函数中，this 的值无法通过 call() 或 apply() 方法来修改。**

---

## Promise

`Promise.all`会在promise数组其中一个promise失败后停止；当 `Promise.all()` 变成接受状态（fulfilled）时，`then` 方法会被调用。该方法有一个参数，[`then` 方法会被调用。该方法有一个参数，即接受的最终结果（the fulfillment value）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)[1](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)。这个参数是一个数组，包含了所有传递给 `Promise.all()` 的 promises 的最终结果。

`Promise.allSettled`会在所有Promise失败或者成功后完成，

---

## fetch和xhr

Fetch和XHR都是获取远端数据的方式。**Fetch是原生js方法**，没有使用XMLHttpRequest对象，使用fetch可以不用引用http的类库即可实现。它提供了一种简单，合理的方式来跨网络异步获取资源。

**而XMLHttpRequest（XHR）是一个构造函数**，对象用于与服务器交互。**它基于事件机制实现请求成功与失败**的回调，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱。而Fetch通过Promise来实现回调，调用更加友好。

在处理HTTP头部方面，XMLHttpRequest有一个setRequestHeader()方法用于设置HTTP请求头部。此方法必须在open()方法和send()之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头1。

而Fetch API提供了一个Headers接口，它与Map类型都有get()、set()、has()和delete()等实例方法，可以使用一个可迭代对象来初始化，当然也具有keys()、values()和entries()迭代器接口2。

至于携带cookie方面，根据Fetch规范，Set-Cookie是一个禁止的响应标头，对应的响应在被暴露给前端代码前，必须滤除这一响应标头，即浏览器会阻止前端JavaScript代码访问Set-Cookie标头3。

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://www.example.com/');
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.send();
```

```js
fetch('http://www.example.com/', {
  headers: {
    'Content-Type': 'application/json'
  }
});
```

在使用XHR和Fetch时，你可以手动设置HTTP头部，但也有一些头部会被浏览器自动携带。例如，在发送跨域请求时，浏览器会自动添加Origin头部1。

至于Cookie方面，XHR和Fetch默认都不会携带Cookie。如果你想要在请求中携带Cookie，需要进行额外的配置。对于XHR，你需要在$.ajax调用中添加`xhrFields: { withCredentials: true }`。而对于Fetch，你需要在请求配置中添加`credentials: 'include'`。

---

## 实现call方法

核心是通过对象调用函数，显示保证函数内的this指针指向。

```js
Function.prototype.myCall = function(context) {
    context = context || window;
  	// myCall的调用者为函数自身，因此this就指向函数
    context.fn = this;
    var args = [];
    for (var i = 1; i < arguments.length; i++) {
        args.push(arguments[i]);
    }
    var result = context.fn(...args);
    delete context.fn;
    return result;
}
```

