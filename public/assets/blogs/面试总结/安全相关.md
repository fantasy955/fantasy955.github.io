## XSS攻击

XSS攻击，即跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。XSS攻击的本质是利用了**web应用对用户输入的信任**，从而绕过了浏览器的同源策略，执行了非法的脚本。

XSS攻击的危害是：

- 可以盗取用户的cookie，从而获取用户的身份信息，进行身份冒充或者其他恶意操作。
- 可以执行恶意代码，从而对用户的计算机或者网络造成破坏，例如弹出广告、下载木马、修改浏览器设置等。
- 可以破坏页面结构，从而影响用户的正常浏览，例如插入恶意内容、修改页面样式、隐藏页面元素等。
- 可以重定向到其他网站，从而诱导用户进入钓鱼网站或者其他恶意网站，例如伪造登录页面、诱导用户输入敏感信息等。

攻击方式：

- 构造包含恶意js代码的url并诱导用户点击（反射型XSS攻击）；
- DOM-based攻击，同样是通过构造恶意url，当目的是改变用户的DOM结构，

#### 防止富文本中的XSS攻击

富文本编辑器中的XSS攻击主要是通过在富文本中插入恶意脚本来实现的。为了防止这种攻击，我们可以采取以下措施：

1. 过滤富文本中的HTML标签和JavaScript脚本。
2. 对于用户输入的内容进行转义，例如将`<`转义为`<`，将`>`转义为`>`等。
3. 使用CSP（Content Security Policy）来限制页面中可以加载的资源，例如限制只能加载同源的资源。
4. 对于用户上传的图片等文件，需要进行严格的类型检查和文件大小限制，避免上传恶意文件。

**转义：**

转义只是影响了在文档中的内容，而不会影响用户看到的渲染结果。

在HTML中，`<`会被渲染成`<`，`>`会被渲染成`>`。例如，以下代码：

```html
<p>&lt;script&gt;alert('xss')&lt;/script&gt;</p>
```

在页面中会被渲染成：

```
<script>alert('xss')</script>
```

**CSP（Content Security Policy）是一种安全策略，用于限制页面中可以加载的资源：**

CSP可以通过HTTP头信息的Content-Security-Policy字段**或**网页的`<meta>`标签来启用。例如，以下是一个启用CSP的HTTP头信息：

```js
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';
```

```
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
```

上面的代码表示只允许加载同源的资源，script标签只允许加载同源的脚本和内联脚本，style标签只允许加载同源的样式和内联样式。如果页面中存在不符合CSP规则的资源，则会被浏览器拦截并阻止加载。

CSP还支持其他一些配置，例如nonce、hash等，可以进一步提高安全性。在使用CSP时，我们需要根据实际情况进行配置，并及时更新和修复漏洞[1](https://www.ruanyifeng.com/blog/2016/09/csp.html)。

## CSRF攻击

CSRF（**Cross**-site request forgery）的中文名称跨站请求伪造，也被称为“**One** Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。CSRF 则通过伪装成受信任用户的请求来利用受信任的网站，攻击者获取了用户的凭证，例如cookie或者token，主动向服务端发送请求，服务端接收到用户凭证后就认为这是一个正常的用户请求，执行这个请求可能导致用户信息泄漏或者财产损失。

预防的方式只能说对请求中的参数进行验证，增加攻击者伪造请求的难度。

尽管听起来像跨站脚本（XSS），但它与 XSS 非常不同，XSS 利用站点内的信任用户，而 CSRF 则通过伪装成受信任用户的请求来 利用受信任的网站。 与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 XSS 更具危险性。

XSS（corss site script）中文名跨站脚本攻击，攻击原理是原本需要接受数据但是一段脚本放置在了数据中，该脚本可能会：

1. 修改DOM,伪造页面，欺骗用户，获取账号密码等私密信息;
2. 在内面内生成浮窗广告;
3. 可以监听用户的行为,比如addEventListener('keydown') // 监听用户的键盘敲击事件
4. 窃取cookie信息
5. 获取页面数据等

预防方式：

1. 在服务端将script标签转义掉,( `服务器对输入的脚本进行过滤或转码`);
2. 充分使用 `CSP` (限制加载其他域下的资源文件、禁止向第三方提交数据)
3. cookie设置 - HttpOnly (设置这个属性之后`cookie`无法通过js去document.*cookie*读取)

### 区别

XSS攻击和CSRF攻击是两种常见的浏览器攻击方式，它们的区别如下：

- [XSS攻击是指攻击者在网页中注入恶意的脚本代码，当用户浏览这个网页时，脚本代码会被执行，从而导致用户的信息泄露或者被控制](https://www.cnblogs.com/simon7s/p/12421262.html)[1](https://www.cnblogs.com/simon7s/p/12421262.html)[2](https://www.jianshu.com/p/d170e3fa1bb2)[3](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)[4](https://www.jianshu.com/p/01d60c6828d3)[。XSS攻击的目标是用户的浏览器，它不需要用户的身份认证或者Cookie信息](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)[3](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)。
- [CSRF攻击是指攻击者利用用户的Cookie信息，伪造用户的请求发送到服务器，从而执行一些非法的操作](https://www.cnblogs.com/simon7s/p/12421262.html)[1](https://www.cnblogs.com/simon7s/p/12421262.html)[2](https://www.jianshu.com/p/d170e3fa1bb2)[3](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)[5](https://blog.csdn.net/weixin_42615105/article/details/108303684)[。CSRF攻击的目标是服务器，它需要用户的身份认证或者Cookie信息](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)[3](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)。
- [XSS攻击和CSRF攻击的共同点是，它们都需要诱导用户访问一个恶意的网页或者链接，从而触发攻击](https://www.cnblogs.com/simon7s/p/12421262.html)[1](https://www.cnblogs.com/simon7s/p/12421262.html)[2](https://www.jianshu.com/p/d170e3fa1bb2)[3](https://blog.csdn.net/guoqiankunmiss/article/details/116698367)[5](https://blog.csdn.net/weixin_42615105/article/details/108303684)[4](https://www.jianshu.com/p/01d60c6828d3)。

XSS可以通过脚本主动获取网站上的cookie，local Storage以及输入的信息。

CSRF是利用浏览器自动添加cookie的特点，在目标网站未关闭的情况下，恶意网站伪造了一个恶意请求。

---

## 防止cookie被篡改

服务器为每个cookie生成签名。

---

## 新的浏览器安全策略

[即将到来的Chrome新的Cookie策略 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/103420328) 已经到来

- 同站判断方式
  理解两个网站是否为“同一个网站”很重要，判断是否同一网站是通过叫eTLD+1的方式（eTLD = effective Top Level Domain），eTLD定义在上述的Public Suffix List中，**+1表示在左侧加一个子域名**。eTLD+1实际上表示了“可注册的域名”，在实际中eTLD+1一般是不同的主体注册，所以要视为不同的网站。

- SameSite属性（Set-Cookie字段）
  **`SameSite`** 是 HTTP 响应头 [`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie) 的属性之一。它允许您声明该 Cookie 是否仅限于第一方或者同一站点上下文。

  1. **Strict**: 仅限于同站请求

  2. **Lax**: 同站请求，或者跨站的GET的会导致页面URL发生变化的导航行为，包括链接、GET的Form提交。比如在 [http://www.def.com](https://link.zhihu.com/?target=http%3A//www.def.com) 网站的页面中嵌入了一个链接 [http://www.abc.com](https://link.zhihu.com/?target=http%3A//www.abc.com) ，那么在用户点击此链接时发起的初始请求，会带上[http://www.abc.com](https://link.zhihu.com/?target=http%3A//www.abc.com)中设置为Lax的Cookie。而那些设置为Strict的Cookie是不会带上的。这种跨站链接还包括像嵌入到邮件中的链接。跨站请求时，只会带上`Lax`的Cookie。

  3. **None**: 没有限制，同站及跨站请求中都会带上，与传统的方式一样。

     注意如果Cookie设置SameSite=None，还需要同时设置Secure，否则此Cookie会被浏览器拒绝。**设为Secure之后，其它三方网站对我方网站资源的引用必须使用HTTPS，否则还是不会带上此Cookie**，这也要求我方网站必须支持HTTPS。

- META标签的`http-equiv`
  可以使用`http-equiv`属性中的`Content-Security-Policy`来防止XSS攻击。`Content-Security-Policy`可以指定允许加载的内容的来源，从而防止恶意脚本的注入。例如，下面的`meta`标签指定了只允许从当前域名加载脚本：

  ```html
  <meta http-equiv="Content-Security-Policy" content="script-src 'self'">
  ```

- **在同源情况下，浏览器会自动在请求头中携带cookie**。但是，在跨域请求中，默认情况下不会携带cookie。如果你想在跨域请求中携带cookie，需要添加额外的配置。例如，在fetch请求中添加credentials: 'include'，在XMLHttpRequest请求中设置withCredentials属性为true。


---

## 权限验证

Oauth是协议，Token是方法。

OAuth 主要解决的问题是如何安全地授权第三方应用程序访问用户的受保护资源，而无需共享用户的凭证（如用户名和密码）。

OAuth 2.0 是一个授权协议，它允许软件应用代表（而不是充当）资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得令牌（token），并用它来访问资源，并且资源拥有者不用向应用提供用户名和密码等敏感数据。

### TOKEN

jwt的全程是json web token，在开发应用时可以用它来生成用户token，他使用json对象表示信息。

JWT由三段信息构造，不同段之间用`.`号连接，第一部分称为头部，第二部分是称为载荷，第三部分是签名，签名有前面两部分计算得到，避免信息被篡改。

JWT需要我们主动提供一个密钥进行加密解密，这个密钥不能泄漏。

在我们的项目中，使用的是对称加密算法`HS256`，只需要一个密钥。

头部和载荷的原始数据都是json对象，在js的JWA库中，会对这个对象进行stringfy操作，JWT对他们进行base64url（讲base64中用到的+ / =字符替换了）编码。头部和载荷是源数据经过base64url编码后的结果，签名是使用指定对算，用密钥对头部、载荷进行加密的结果。签名可以保证信息不被篡改。

JWT由三部分组成，分别用点号（.）分隔，它们是：头部、载荷和签名。

头部通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。

JWT的缺点是：1.token一经签名，在不使用其他技术的条件下，无法提前撤销。2.token不包含权限控制，因为token的内容需要在后端进行解密。

哈希算法分为带密钥的哈希（HMAC，Keyed-Hashing for Message Authentication）与不带密钥的哈希。

MAC(message authentication code)是通过MAC算法+密钥+要加密的信息一起计算得出的。

同hash算法（消息摘要）相比，消息摘要只能保证消息的完整性，即该消息摘要B是这个消息A生成的。而MAC算法能够保证消息的正确性，即判断确实发的是消息A而不是消息C。

### OAuth2.0

OAuth 主要解决的问题是如何安全地授权第三方应用程序访问用户的受保护资源，而无需共享用户的凭证（如用户名和密码）。

在没有 OAuth 的情况下，用户可能需要将他们的凭证共享给第三方应用程序，以便第三方应用程序能够代表用户访问受保护资源。这种做法存在安全风险，因为第三方应用程序可能会滥用用户的凭证。

OAuth 通过引入**授权服务器**和**访问令牌**来解决这个问题。用户可以通过**授权服务器**向第三方应用程序授予访问令牌，该令牌表示第三方应用程序已获得访问受保护资源的权限。这样，第三方应用程序就无需获取用户的凭证，而只需使用访问令牌来访问受保护资源。

这里涉及三方：应用程序（用户账号）、授权服务器（微信）、第三方（客户端，小程序）。小程序想要获取用户账号的访问权限，用户授权微信生成访问令牌，令牌中包含了第三方信息，以及权限信息，保证令牌不被滥用。

1. 用户访问客户端，后者将前者导向认证服务器。
2. 用户选择是否给予客户端授权。
3. 假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。
4. 客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。
5. 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。

### JWT加密算法

- SHA- Secure Hash Algorithm。

- 签名和加密

  签名的目的是确定消息来源，jwt的头部和载荷都是公开的，但里面没有包含敏感信息；

  加密是确保信息不被其他人获取，例如对jwt的头部和载荷进行加密；

- 什么信息需要被添加进token；
  用户id、创建时间、有效时间、类型；
  校验时只判断过期和token是否属于当前发送请求的用户；

- MAC与哈希算法；

- 加密算法类型；

  加密算法可分为对称加密和非对称加密两种类型（HMAC, RSA）。

  HMAC即Hash-based Message Authentication Code，是一种基于哈希的消息加密算法，通过密钥、消息、和哈希函数计算出消息的加密结果。

  哈希函数例如`SHA-2` `SHA-3`。

  哈希函数是一种单向函数，它将任意长度的输入数据映射到**固定长度**的输出数据。哈希函数的特点包括：

  - 确定性：对于相同的输入，哈希函数总是产生相同的输出。
  - 快速计算：对于给定的输入，计算其哈希值是高效的。
  - 抗修改：对输入数据进行微小的修改都会导致输出数据发生很大的变化。
  - 抗碰撞：找到两个不同的输入，它们具有相同的哈希值是非常困难的。

  由于哈希函数是单向函数，因此无法从哈希值反推出原始数据。也就是说，哈希函数并不是加密算法，它无法进行解密。它通常用于验证数据完整性和一致性，而不是用于加密。

  密钥可以让第三方难以伪造签名，如果不使用密钥，那么攻击者可以根据消息结构，使用主流的哈希函数计算消息的哈希值，一旦与官方颁布的签名一致，就可以伪造签名了。

  **JWT中的头部和载荷并没有加密，它只根据签名验证这个token是否是自己产生的。**

- 使用非对称加密的场景：接收方需要验证签名。

  **如果接收方需要验证token的有效性的话，必须要自己生成签名。**

  公钥用于**加密**数据和**验证**数字签名。任何人都可以获取公钥，并使用它对数据进行加密。加密后的数据只能由拥有对应私钥的人解密。此外，公钥还可以用于验证数字签名。发送方使用私钥对数据进行签名，接收方使用发送方的公钥验证签名，以确认数据的来源和完整性。

  私钥用于**解密**数据和**生成**数字签名。私钥必须保密，只能由拥有者使用。拥有者可以使用私钥解密由公钥加密的数据。此外，拥有者还可以使用私钥对数据进行签名，以证明数据的来源。

  数据加密用于保护信息的隐私性。它通过使用加密算法和密钥对数据进行加密，使得只有拥有正确密钥的人才能解密并访问数据。数据加密可以防止未经授权的访问者查看数据内容。

  数字签名用于验证信息的来源和完整性。它通过使用加密算法和密钥对数据进行签名，生成一个与数据相关的签名值。接收方可以使用发送方的公钥验证签名，以确认数据的来源和完整性。数字签名可以防止数据在传输过程中被篡改。

  在OAuth 2.0协议中，**客户端可以使用私钥对JWT进行签名**，并将签名后的JWT作为客户端凭证发送给授权服务器。授权服务器使用客户端的公钥验证JWT的完整性和真实性，从而验证客户端的身份。

  **使用公钥验证签名：**当发送方使用私钥对数据进行签名时，它会对数据进行哈希运算，生成一个与数据相关的哈希值。然后，发送方使用私钥对哈希值进行加密，生成数字签名。发送方将数字签名与原始数据一起发送给接收方。

  接收方在收到数据和数字签名后，可以使用发送方的公钥对数字签名进行解密，得到哈希值。接收方还会对收到的数据进行哈希运算，生成一个新的哈希值。接收方将这两个哈希值进行比较，如果它们相同，则说明数据未被篡改，并且来自预期的发送方。

  **对签名进行加密可以提供额外的安全性**。加密可以防止攻击者查看签名内容，从而更难伪造签名。此外，使用非对称加密算法（例如RSA）对签名进行加密还可以确保只有拥有私钥的人才能验证签名的有效性。

  （公钥加密，私钥解密）

  RSA是一种非对称加密算法。常见非对称加密算法RSA，DSA

- 非对称加密生成令牌

  1. 首先，需要生成一对非对称密钥，即公钥和私钥。公钥可以公开发布，而私钥需要妥善保管。
  2. 然后，根据需要生成令牌的数据。例如，在OAuth 2.0中，令牌可能包含用户ID、客户端ID、授权范围和过期时间等信息。
  3. 接下来，可以使用私钥对令牌进行数字签名。这样，接收方可以使用公钥验证签名，以确保令牌未被篡改。
  4. 最后，可以将令牌和签名一起发送给接收方。接收方可以使用公钥验证签名，并根据需要使用令牌。

  使用私钥对令牌进行数字签名是指使用非对称加密算法中的私钥对令牌数据进行签名，以生成一个独特的数字签名。这个数字签名可以用来验证令牌数据的完整性和真实性。

  **数字签名的过程通常包括以下步骤**：

  1. 首先，需要使用哈希算法对令牌数据进行哈希处理，以生成一个固定长度的哈希值。
  2. 然后，使用非对称加密算法中的私钥对哈希值进行加密，以生成数字签名。
  3. 最后，可以将数字签名附加到令牌数据上，一起发送给接收方。

  接收方在收到令牌数据和数字签名后，可以使用发送方的公钥对数字签名进行解密，**以获取原始的哈希值**（**原始信息哈希得到的**）。然后，接收方可以使用相同的哈希算法对令牌数据进行哈希处理，并将计算出的哈希值与解密后的哈希值进行比较。如果两者相同，则表明令牌数据未被篡改，并且确实来自发送方。

  使用公钥加密后只能用私钥解密，**反之，私钥加密后也只能用公钥解密**。至于公钥加密和私钥加密的区别和目的，后面讲述身份认证时会进行详细的说明。

  **接收方需要验证消息没有被篡改时，需要使用非对称加密，因为发送方的密钥不能外泄**。由于签名是私钥生成的，任何第三方不能伪造签名，伪造的签名在接收方解密时也不能得到正确的消息摘要。

  [公钥、私钥、对称加密、非对称加密、混合加密、摘要、签名、证书及CA_摘要公钥私钥数字签名_RickChandler的博客-CSDN博客](https://blog.csdn.net/qq_40837070/article/details/127484370?spm=1001.2101.3001.4242.1&utm_relevant_index=3)

