每个组件通常有自己的状态，状态会影响组件在页面上的显示内容；不同组件之间通常需要共享状态，有些状态在整个应用中被很多的组件所共享，这些组件之间的关系可能会很复杂，传统的组件间通信方式无法简洁地解决这种状态传递的问题。

React中可以依赖Context共享状态，由于[Context的数据是通过组件树的层级传递的，而不是通过props显式地传递](https://juejin.cn/post/6969188665532612639)[1](https://juejin.cn/post/6969188665532612639)[。这样就不容易看出哪些组件依赖于哪些数据，以及数据的修改是从哪里来的](https://juejin.cn/post/7085190229782429727)[2](https://juejin.cn/post/7085190229782429727)[3](https://zhuanlan.zhihu.com/p/110085652)。

## redux

### Redux与react-redux

React只是一个状态管理框架，可以与任何前端框架结合使用。在我们开发中，一般都需要一个额外的库帮助我们自动关联状态与组件。

在不使用第三方绑定库的情况下，为了让redux与UI关联起来，我们首先需要创建一个redux store，然后订阅redux store的状态变更，在订阅的回调中获取最新的状态，提取与当前UI相关的状态，使用最新的状态更新UI。同时，当UI的输入影响到状态时，执行`dispath`方法变更状态。

订阅、检测最新状态、触发重新UI的重新渲染，可以实现为通用的逻辑代码，第三方绑定库就是要做到这些。

Redux不关心是哪个组件触发了更新，它只关注action和reducer的交互，`react-redux`中的`connect`方法将组件与`store`连接起来，并自动监听store里的state变化。

## vuex

- 模块化
  每个模块都是一个对象，对象上有自己的`state` `actions` `getters` `mutations`属性。在`createStore`的传入对象上添加`modules`属性，整合这些模块。
  模块默认的命名空间是全局，假如有一个`demo`模块，他使用全局命名空间的话，可以直接使用`state.***`访问`demo.***`上的状态。`action`、`mutation`和`getter`同理能被访问，因此如果多个非命名空间模块使用同样的状态名词时，会出现命名冲突。
  模块内的`getter`（`state, getters, rootState`）、`mutation`函数的第一个参数都是**局部状态**；`action`函数会传入一个`contex`上下文对象，`{ state, commit, rootState }`，可以访问局部状态和根状态。
  模块可以出现嵌套，模块的子模块同样可以启用命名空间。
  即使没有使用命名空间，也可以通过模块名称访问特定模块上的状态，**但是不能**通过模块名称来访问模块上的getter函数或mutation函数。**因此**，没有使用命名空间，那么**不同模块的状态不会发生冲突**，因为它们是通过模块名称来访问的。但是，如果您没有使用命名空间，那么所有模块中定义的getters、mutations和actions都会注册到全局命名空间中。这意味着，如果不同模块中存在同名的getters、mutations或actions，它们将会发生冲突。

## pinia

Pinia没有mutation，只有state、getters和actions（同步或异步）来修改state数据。此外，Pinia的语法比Vuex更容易理解和使用，更灵活。
在Vuex中，全局状态是通过在根store实例中定义state来实现的。您可以通过`this.$store.state`来访问全局状态。
在Pinia中，您可以创建一个单独的store来存储全局状态。您可以使用`useStore`函数来访问该store，并使用返回的对象来访问和修改全局状态。

Vuex 有一个概念，带有多个模块的单一 store。这些模块可以被命名，甚至可以互相嵌套。
将这个概念过渡到 Pinia 最简单的方法是，你以前使用的每个模块现在都是一个 *store*。每个 store 都需要一个 `id`，类似于 Vuex 中的命名空间。这意味着每个 store 都有命名空间的设计。嵌套模块也可以成为自己的 store。互相依赖的 store 可以直接导入其他 store。
