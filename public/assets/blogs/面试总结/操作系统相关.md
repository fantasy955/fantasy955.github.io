## 内存管理

- **页表是虚拟内存的概念**。段页式内存管理。内存分页，页内分段。系统为每个进程或作业分配一张段表，包含了页表的地址和页表的长度。逻辑地址--->线性地址--->物理地址，首先利用页目录地址找操作系统的**页表**，然后根据**页表索**引找到页地址，然后根据**页内偏移**，找到物理地址。



## 进程管理



## 线程

### 线程安全

线程安全指任何在多线程环境下能够正确运行的代码，包括对象、方法、类和数据结构等。当多个线程同时访问同一个数据或代码时，如果不需要额外的同步或协调操作，且能够获得正确的结果，那么这些数据或代码就是线程安全的。

### 保证线程安全

- 使用synchronized 关键字来同步方法或代码块。
  如果多个线程同时访问了一个使用 synchronized 关键字修饰的方法，那么这些线程将会被阻塞，直到获得该方法的锁。当一个线程获得锁并进入该方法时，其他线程将继续等待。当该线程退出该方法时，它将释放锁，然后由等待的线程中的一个获得锁并进入该方法。
- 使用 java.util.concurrent 包中提供的 Lock 接口及其实现来显式锁定和解锁共享数据。

每个 Java 对象都有一个与之关联的监视器对象，无论该对象是否包含同步代码。监视器对象是 Java 虚拟机（JVM）内置的一种机制，用于协调对对象的访问。

**即使一个对象没有同步代码，它仍然可以被用作锁对象**，以保护其他代码的执行。例如，您可以使用 synchronized 关键字来同步一个代码块，并指定一个普通对象作为锁对象，如下所示：

```java
Object lock = new Object();
...
synchronized (lock) {
    // code to be synchronized
}
```

在这种情况下，当一个线程进入同步代码块时，它会获得 lock 对象的监视器锁。如果其他线程也试图进入该同步代码块，它们将被阻塞，直到当前线程退出同步代码块并释放锁。

因此，即使一个对象没有同步代码，它仍然可以被用作锁对象，以保护其他代码的执行。
