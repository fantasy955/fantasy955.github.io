## keep-alive

> [HTTP协议的Keep-Alive 模式 - 简书 (jianshu.com)](https://www.jianshu.com/p/49551bda6619)
>
> HTTP的Keep-Alive与TCP的Keep Alive，有些不同，两者意图不一样。前者主要是 TCP连接复用，避免建立过多的TCP连接。而TCP的Keep Alive的意图是在于保持TCP连接的存活，就是发送心跳包。

## TLS协议4次握手

传输层安全性协议（英语：Transport Layer Security，缩写作TLS）

> 由于 HTTPS 的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时，IETF 对 SSL3.0 进行了标准化，并添加了少数机制(但是几乎和 SSL3.0 无差异)，标准化后的 SSL 更名为 TLS1.0(Transport Layer Security 安全传输层协议)，可以说 TLS 就是 SSL 的新版本3.1，并同时发布 “RFC2246-TLS 加密协议详解”。

使用非对称加密算法生成密钥，并交换密钥。

- **客户端发出请求Client Hello**

  首先，客户端先向服务器发出加密通信的请求，这被叫做clienthello请求。

  在这一步，客户端主要向服务器提供以下信息：

  **支持的协议版本**，比如TLS1.0版本；
  **支持的加密方法**，比如RSA公钥加密；
  **一个客户端生成的随机数**(client random), 稍后用于生成对话密钥(session key)
  由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。

- **服务器回应Server Hello**

  服务器收到客户端请求后，向客户端发出回应，这叫做serverhello。

  这一步服务器主要干三件事：

  确认使用的加密通信协议版本，比如TLS1.00版本。如果游览器与服务器支持的版本不一致，服务器关闭加密通信；
  确认使用的加密方法（客户端所支持），比如RSA公钥加密；
  将**服务器证书**、**非对称加密的公钥**，以及**一个随机数(Server random)**发送给客户端游览器
  服务端在接收到客户端的Client Hello之后，服务端需要将自己的证书发送给客户端。这个证书是对于服务端的一种认证。例如，客户端收到了一个来自于称自己是http://www.alipay.com的数据，但是如何证明对方是合法的alipay支付宝呢？这就是证书的作用，**支付宝的证书可以证明它是alipay**，而不是财付通。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。

- 客户端回应

  客户端收到服务器回应以后，首先**验证服务器证书**，验证手段就是执行如下三种检查：

  检查证书**是否已过期**；
  检查证书中的域名与**实际域名是否一致**；
  检查证书是否是**可信机构颁布**的；
  如果，上述过程中有任何一个环节发现问题，那么浏览器就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书受信任，或者是用户接受了不受信的证书，**浏览器会生成一串新的随机数（Premaster secret ）**，并用证书中提供的公钥加密，发送给服务器。

  此时，浏览器会根据前三次握手中的三个随机数：

  ​	Client random
  ​	Server random
  ​	Premaster secret

  客户端收到服务端的回复后利用服务端的**公钥**，加上**新的随机数–Premaster secret** 通过服务端下发的**公钥及加密方法**进行加密，得到**会话密钥（Premaster secret）**，发送给服务器。

- 服务端回应

  服务端收到客户端的回复，利用已知的加密解密方式进行解密，服务器收到客户端的第三个随机数（ Premaster secret） 之后，使用同样的算法计算出 **“会话密钥” （Session Key）**。

  至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 “会话密钥” 加密内容。（非对称加密解密将不再使用，接下来完全由对称加密接手了，因为密钥已经安全的传送给了通信的双方）

`Premaster secret`使用**服务端公钥**进行非对称加密，必须使用**服务端的私钥**进行解密。即使数据在输出中被其他人得到，也无法解密出`Premaster secret`。

服务端解密出`Premaster secret`，使用相同的算法生成**会话密钥**，由于会话密钥没有在客户端与服务端的通信中出现，第三方无法解密传输的信息。

第一次和第二次握手用于确定加密算法和交换随机数。这阶段的信息是明文传输的。第三方可以获得客户端随机数和服务端随机数。

第三次握手客户端使用非对称加密算法，借助服务器公钥，加密`Premaster secret`。第三方无法获取这个随机数，因为他们没有私钥进行解密。同时，会话密钥已经能够计算出来，但是其他人没有`Premaster secret`，无法计算。因此，正向和逆向都无法获得会话密钥。

## HTTPS如何防止信息被劫持

两个方面，一是客户端会验证服务器的证书，保证服务器身份的真实性。二是通过TLS协议保证传输数据的安全。

---

## 跨域

最常用的两种应该是jsonp和cors，剩余一种是nginx反向代理。反向代理解决跨域问题的原理是通过伪造请求使得HTTP请求为同源的，然后将同源的请求发送到反向代理服务器上，由反向代理服务器去请求真正的URL，这样就绕过直接请求真正的URL导致跨域问题。

jsonp的有点是没有兼容性问题，是否调用后端返回的回调方法也是有前端决定的。其原理是script标签的src属性不受同源策略的影响，后端返回的内容会被替换到script标签中。前端定义了一个函数并挂载到window对象上，函数的参数由后端提供，后端返回的字符串是调用该函数并且传递参数。缺点是请求失败并不会返回HTTP状态码，无法进行出错处理。只支持Get请求。

CORS是一种运行跨域资源共享的策略。CORS的缺点是会降低服务器的安全性，特别是允许任何源访问资源。CORS还需要额外的预检请求，增加了网络开销。
