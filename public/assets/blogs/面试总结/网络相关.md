## keep-alive

> [HTTP协议的Keep-Alive 模式 - 简书 (jianshu.com)](https://www.jianshu.com/p/49551bda6619)
>
> HTTP的Keep-Alive与TCP的Keep Alive，有些不同，两者意图不一样。前者主要是 TCP连接复用，避免建立过多的TCP连接。而TCP的Keep Alive的意图是在于保持TCP连接的存活，就是发送心跳包。

## TLS协议4次握手

传输层安全性协议（英语：Transport Layer Security，缩写作TLS）

> 由于 HTTPS 的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时，IETF 对 SSL3.0 进行了标准化，并添加了少数机制(但是几乎和 SSL3.0 无差异)，标准化后的 SSL 更名为 TLS1.0(Transport Layer Security 安全传输层协议)，可以说 TLS 就是 SSL 的新版本3.1，并同时发布 “RFC2246-TLS 加密协议详解”。

使用非对称加密算法生成密钥，并交换密钥。

- **客户端发出请求Client Hello**

  首先，客户端先向服务器发出加密通信的请求，这被叫做clienthello请求。

  在这一步，客户端主要向服务器提供以下信息：

  **支持的协议版本**，比如TLS1.0版本；
  **支持的加密方法**，比如RSA公钥加密；
  **一个客户端生成的随机数**(client random), 稍后用于生成对话密钥(session key)
  由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。

- **服务器回应Server Hello**

  服务器收到客户端请求后，向客户端发出回应，这叫做serverhello。

  这一步服务器主要干三件事：

  确认使用的加密通信协议版本，比如TLS1.00版本。如果游览器与服务器支持的版本不一致，服务器关闭加密通信；
  确认使用的加密方法（客户端所支持），比如RSA公钥加密；
  将**服务器证书**、**非对称加密的公钥**，以及**一个随机数(Server random)**发送给客户端游览器
  服务端在接收到客户端的Client Hello之后，服务端需要将自己的证书发送给客户端。这个证书是对于服务端的一种认证。例如，客户端收到了一个来自于称自己是http://www.alipay.com的数据，但是如何证明对方是合法的alipay支付宝呢？这就是证书的作用，**支付宝的证书可以证明它是alipay**，而不是财付通。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。

- 客户端回应

  客户端收到服务器回应以后，首先**验证服务器证书**，验证手段就是执行如下三种检查：

  检查证书**是否已过期**；
  检查证书中的域名与**实际域名是否一致**；
  检查证书是否是**可信机构颁布**的；
  如果，上述过程中有任何一个环节发现问题，那么浏览器就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书受信任，或者是用户接受了不受信的证书，**浏览器会生成一串新的随机数（Premaster secret ）**，并用证书中提供的公钥加密，发送给服务器。

  此时，浏览器会根据前三次握手中的三个随机数：

  ​	Client random
  ​	Server random
  ​	Premaster secret

  客户端收到服务端的回复后利用服务端的**公钥**，加上**新的随机数–Premaster secret** 通过服务端下发的**公钥及加密方法**进行加密，得到**会话密钥（Premaster secret）**，发送给服务器。

- 服务端回应

  服务端收到客户端的回复，利用已知的加密解密方式进行解密，服务器收到客户端的第三个随机数（ Premaster secret） 之后，使用同样的算法计算出 **“会话密钥” （Session Key）**。

  至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 “会话密钥” 加密内容。（非对称加密解密将不再使用，接下来完全由对称加密接手了，因为密钥已经安全的传送给了通信的双方）

`Premaster secret`使用**服务端公钥**进行非对称加密，必须使用**服务端的私钥**进行解密。即使数据在输出中被其他人得到，也无法解密出`Premaster secret`。

服务端解密出`Premaster secret`，使用相同的算法生成**会话密钥**，由于会话密钥没有在客户端与服务端的通信中出现，第三方无法解密传输的信息。

第一次和第二次握手用于确定加密算法和交换随机数。这阶段的信息是明文传输的。第三方可以获得客户端随机数和服务端随机数。

第三次握手客户端使用非对称加密算法，借助服务器公钥，加密`Premaster secret`。第三方无法获取这个随机数，因为他们没有私钥进行解密。同时，会话密钥已经能够计算出来，但是其他人没有`Premaster secret`，无法计算。因此，正向和逆向都无法获得会话密钥。

## HTTPS如何防止信息被劫持

两个方面，一是客户端会验证服务器的证书，保证服务器身份的真实性。二是通过TLS协议保证传输数据的安全。

---

## 跨域

最常用的两种应该是jsonp和cors，剩余一种是nginx反向代理。反向代理解决跨域问题的原理是通过伪造请求使得HTTP请求为同源的，然后将同源的请求发送到反向代理服务器上，由反向代理服务器去请求真正的URL，这样就绕过直接请求真正的URL导致跨域问题。

jsonp的有点是没有兼容性问题，是否调用后端返回的回调方法也是有前端决定的。其原理是script标签的src属性不受同源策略的影响，后端返回的内容会被替换到script标签中。前端定义了一个函数并挂载到window对象上，函数的参数由后端提供，后端返回的字符串是调用该函数并且传递参数。缺点是请求失败并不会返回HTTP状态码，无法进行出错处理。只支持Get请求。

CORS是一种运行跨域资源共享的策略。CORS的缺点是会降低服务器的安全性，特别是允许任何源访问资源。CORS还需要额外的预检请求，增加了网络开销。

---

## HTTP1.0 、 HTTP1.1和HTTP2.0

http1.0是无状态无连接的应用层协议，无连接特性导致每次发送HTTP请求都会与服务器新建一个TCP连接，浪费时间与流量在TCP连接的建立过程。并且HTTP1.0规定，请求必须在前一个请求的响应到达后才能发送，如果前一个请求的响应不到达，就会阻塞后面的请求。

HTTP1.1增加了一个connection字段，可以保持连接不断开，避免每次请求都重复建议TCP连接，提高了网络的利用率。到由于只有一个TCP连接，很容易产生队头阻塞的情况（服务器可以收到多个HTTP请求，但是必须按照客户端请求的顺序返回）。因此另一种并行，即浏览器创建多个TCP连接，是更加常用的并行方法。

HTTP2.0是在HTTP1.x的基础上进行了相应的修改，它具有以下几个主要特点：1、二进值协议；2、多路复用；3、头部压缩；4、服务器推送。

在HTTP2.0中，流（stream）是一个抽象的概念，它表示一个独立的、双向的数据流。每个流都有一个唯一的标识符，并且可以承载多个消息。虽然多个流可以在同一个TCP连接中并行传输，但它们仍然是独立的。

**个人理解：**

在HTTP1.0和1.1中，HTTP报文是一个整体，**如果多个HTTP混合在一起传输，无法还原HTTP报文**(TCP干的)。（在底层传输过程中，HTTP报文会被转换成二进制串并拆分，并以二进制进行传输，在上层进行还原。）

HTTP2.0提出了流和帧的概念，一个TCP连接可以包含多个流，一个流包含多个帧。一个流可以包含多个HTTP请求/响应（都是消息）。帧有一个标识符标记自己属于哪一个流，那么一个流中不同消息的帧又如何区分呢？——在同一个流中，同一个消息的帧必须依次发送；只有不同流中的消息和帧才可以交错发送。HTTP2.0中有一种帧叫做RST_STREAM帧，它可以用来终止一个流。

其中最重要的是流的概念，这让多个HTTP请求/响应可以同时传输（属于不同流），而以前可以认为只有一个流。

为什么一个流要包含多个消息呢？不能直接创建一个新的流吗？

**一个流内的HTTP请求必须按序到达（与HTTP1.1中的连接复用是一致的**。

[HTTP2.0不直接使用一个流的原因可能是为了避免队头阻塞](https://zhuanlan.zhihu.com/p/102561034)[1](https://zhuanlan.zhihu.com/p/102561034)[。如果只有一个流，那么所有的请求和响应都要按照顺序发送和接收，如果某个请求或响应被阻塞，那么后面的所有请求或响应也会被阻塞，导致客户端迟迟收不到数据](https://zhuanlan.zhihu.com/p/102561034)[1](https://zhuanlan.zhihu.com/p/102561034)[。而HTTP2.0中使用多个流，可以实现并行传输，不同流中的帧可以交错发送和接收，不会因为某个流的阻塞而影响其他流](https://zhuanlan.zhihu.com/p/89471776)[2](https://zhuanlan.zhihu.com/p/89471776)[3](https://juejin.cn/post/7034668672262242318)。

[一个流包含多个消息的原因是为了提高传输效率和利用带宽。如果每个消息都创建一个新的流，那么就会增加流的数量和管理的复杂度，而且可能会导致一些流被闲置或者浪费](https://blog.csdn.net/qq_34629352/article/details/105467221)[1](https://blog.csdn.net/qq_34629352/article/details/105467221)[2](https://zhuanlan.zhihu.com/p/89471776)[。HTTP2.0中，一个流可以承载双向消息传输，也就是说客户端和服务器可以在同一个流中发送和接收多个请求和响应](https://zhuanlan.zhihu.com/p/89471776)[2](https://zhuanlan.zhihu.com/p/89471776)[3](https://zhuanlan.zhihu.com/p/405149337)[。这样就可以减少TCP连接的数量，节省握手的时间，提高并发性能](https://blog.csdn.net/qq_34629352/article/details/105467221)[1](https://blog.csdn.net/qq_34629352/article/details/105467221)[2](https://zhuanlan.zhihu.com/p/89471776)。



HTTP2.0报文的头部长度不是固定的，而是根据实际情况动态变化的。**HTTP2.0使用了HPACK算法来对头部进行压缩**，减少了头部的大小和冗余。HPACK算法使用了两种方法来压缩头部：静态表和动态表。静态表是一个预定义的常用头部字段的列表，动态表是一个根据请求和响应过程中出现的头部字段动态更新的列表。这样，HTTP2.0可以通过发送索引值来代替完整的头部字段，从而节省带宽和提高效率。

HTTP2.0报文通过二进制分帧来将HTTP语义信息（如头部，请求方法，状态码等）和应用数据（如HTML，CSS，JS等）分离，并封装成不同类型的帧。每个帧都有一个固定的9字节的头部，包含了帧类型，长度，标志位和流标识符。不同类型的帧有不同的作用和格式。例如，HEADERS帧用于传输HTTP头部信息，DATA帧用于传输应用数据，SETTINGS帧用于传输连接配置参数等。

HTTP2.0报文有10种类型的帧，分别是**DATA**，**HEADERS**，PRIORITY，RST_STREAM，SETTINGS，**PUSH_PROMISE**，PING，GOAWAY，WINDOW_UPDATE和CONTINUATION。每种帧都有不同的作用和格式1。例如，DATA帧用于传输应用数据，HEADERS帧用于传输HTTP头部信息，PRIORITY帧用于指定流的优先级等1。

二进制分帧有很多优点。首先，**它可以将HTTP语义信息和应用数据分离**，并封装成不同类型的帧。这样可以实现多路复用（multiplexing），即在一个TCP连接上同时传输多个请求和响应。这样可以减少TCP连接的数量和开销，并提高网络利用率。其次，它可以实现流控制（flow control），即根据接收方的能力来调整发送方的速度。这样可以避免发送方过载接收方，并保证数据传输的平衡和稳定。第三，它可以实现优先级（priority），即根据不同流的重要性来分配资源和顺序。这样可以提高用户体验和响应速度，并避免低优先级的流阻塞高优先级的流。

二进制分帧也有一些机制来保证顺序性和完整性。首先，在每个帧头部都有一个流标识符（stream identifier），用于标识该帧属于哪个流。这样就可以将不同类型的帧按照所属流进行组合和解析，并保证每个流内部的顺序性。其次，在每个DATA帧头部都有一个结束标志位（END_STREAM），用于标识该DATA帧是否是该流中最后一个DATA帧  \[^1 ^\] [ ^2 ^] [ ^9 ^]. 这样就可以判断该流是否已经完成了数据传输，并保证每个流内部的完整性[ ^9 ^]. 第三，在每个HEADERS 帧头部都有一个连续标志位（END_HEADERS），用于标识该HEADERS 帧是否是该头部块中最后一个HEADERS 帧[ ^1 ^] [ ^2 ^] [ ^9 ^]. 这样就可以判断该头部块是否已经完成了头部信息传输，并保证每个头部块内部的完整性[ ^9 ^].

**将报文转换为二进值**还可以降低报文总大小，例如数字1234在HTTP1.X中使用文本传输会被转换为字符串“1234”，消耗更多字节。HTTP2.0会采样多中方式优化二进值编码后的报文大小。

## 服务器推送

举例：客户端请求一个html文件，服务端把html文件以及其他资源文件一起返回给前端。

---

## HTTP

### 请求/响应的常用头部

- 常用的通用头部字段：

  Cache-Control、Connection、

- 常用的请求头部字段：

  [Accept：指定客户端能够接收的内容类型](https://www.cnblogs.com/lauhp/p/8979393.html)[1](https://www.cnblogs.com/lauhp/p/8979393.html)。

  [Accept-Charset：浏览器可以接受的字符编码集](https://www.cnblogs.com/lauhp/p/8979393.html)[1](https://www.cnblogs.com/lauhp/p/8979393.html)。

  If-Match、If-Modified-Since、If-None-Match、If-Range、Range

  **refer**：用于表示当前请求页面的来源页面的地址

- 常用的响应头部字段：

  Accept-Ranges（表示接收字节的请求范围）、ETag、Location（用于重定向，指向重定向的链接）

  **origin**：响应中的origin字段是一个用于跨域资源共享（CORS）的字段，它表示当前请求资源所在页面的协议和域名[1](https://blog.csdn.net/xiaolinlife/article/details/119825880)。服务器可以根据这个字段来判断是否允许跨域访问，**并返回相应的Access-Control-Allow-Origin字段**。

### 缓存控制

- CACHE-CONTROL: no-cache，强制协商缓存；
- CACHE-CONTROL: no-store，禁止使用缓存；

### Etag的缺陷

[ETag是一种HTTP响应头，用于标识资源的特定版本，可以用来优化缓存和带宽。](https://e-words.jp/w/ETag.html)[1](https://e-words.jp/w/ETag.html)[2](https://ja.wikipedia.org/wiki/HTTP_ETag)[3](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/ETag)

ETag的缺陷有以下几点：

- [ETag的生成方式没有统一的标准，不同的服务器可能会生成不同的ETag值，导致缓存失效。](https://ja.wikipedia.org/wiki/HTTP_ETag)[2](https://ja.wikipedia.org/wiki/HTTP_ETag)
- [ETag的值可能会泄露服务器的信息，比如文件系统或操作系统的类型。](https://ja.wikipedia.org/wiki/HTTP_ETag)[2](https://ja.wikipedia.org/wiki/HTTP_ETag)
- [ETag的计算和比较需要消耗一定的CPU资源，可能会影响服务器的性能。](https://ja.wikipedia.org/wiki/HTTP_ETag)[2](https://ja.wikipedia.org/wiki/HTTP_ETag)
- [ETag可能会被浏览器或代理服务器忽略或修改，导致缓存不一致。](https://ja.wikipedia.org/wiki/HTTP_ETag)[2](https://ja.wikipedia.org/wiki/HTTP_ETag)

### HTTP跳转HTTPS

HTTP强制跳转HTTPS的字段是一种用于将HTTP请求重定向到HTTPS的方法，可以提高网站的安全性和信任度。

HTTP强制跳转HTTPS的字段有以下几种：

- 在Nginx服务器上使用rewrite方法，将所有的HTTP请求重写为HTTPS请求。
- 在.htaccess文件中添加相应的规则，将所有的HTTP请求重定向为HTTPS请求。
- 在HTML页面中使用meta标签，设置http-equiv属性为"refresh"，content属性为"0;url=https://…"，将当前页面跳转到HTTPS页面。



---

## TCP协议

TCP协议工作在传输层，它负责在两个应用程序之间提供可靠的、面向连接的数据传输服务。它通过序列号、确认号、重传机制等方法来保证数据的可靠传输。此外，TCP还提供流量控制和拥塞控制功能，以防止发送方发送过快导致接收方或网络拥塞。

TCP协议是由操作系统内核支持的。大多数现代操作系统都内置了对TCP协议的支持，可以让应用程序通过套接字（socket）接口来使用TCP协议进行网络通信。因此TCP中的心跳包功能一般不启用，而是让应用程序（应用层）判断是否应该继续使用连接（即使应用被阻塞或发生其他情况不工作了，操作系统还在尝试维持连接，并没有用）。

### 流量控制和拥塞控制

 流量控制和拥塞控制都是TCP协议中用来**控制发送速率的机制**，但它们的**目的和方法**不同。

流量控制是用来**防止发送方发送速度过快**，导致接收方来不及处理而溢出的机制。它通过**接收方在TCP报文中的窗口字段**来告诉发送方自己还能接收多少数据，从而控制发送方的发送速率。

拥塞控制是用来防止网络拥塞的机制。当网络中的路由器或链路过载时，会出现丢包、延迟增大等现象。TCP协议通过检测丢包和延迟等信号来判断网络是否拥塞，并通过调整拥塞窗口来控制发送速率，以减轻网络拥塞。

流量控制和拥塞控制都可以影响TCP的发送速率，但它们的目标不同：流量控制是为了保护接收方，而拥塞控制是为了保护网络。

**接收方TCP字段中的窗口大小不仅会影响一个TCP报文的大小，还会影响发送方能够发送的数据总量。**

在TCP协议中，**发送方在发送数据时需要遵守两个限制条件**：拥塞窗口和接收方窗口。拥塞窗口是由拥塞控制算法动态调整的，用来控制发送方的发送速率，以减轻网络拥塞。接收方窗口是由接收方返回的，用来告诉发送方接收方能够接收的数据量，以便进行流量控制。

当发送方发送数据时，它会根据拥塞窗口和接收方窗口中较小的一个来确定能够发送的数据总量。也就是说，发送方能够发送的数据总量不能超过拥塞窗口和接收方窗口中较小的一个。

### 如何确定第一次发送包的大小

在TCP连接建立时，发送方和接收方会通过三次握手来交换彼此的最大报文段长度（MSS），这个值通常取决于双方的网络接口卡的最大传输单元（MTU）减去IP和TCP头部的长度。发送方在发送数据时会根据MSS来确定每个TCP报文段的大小。

此外，在TCP连接建立后，发送方还会根据接收方在TCP报文中的窗口字段来确定自己能够发送的数据量，以便进行流量控制。

### 如何实现拥塞控制

在拥塞控制方面，TCP协议采用了**慢启动算法**，初始拥塞窗口大小为1个MSS，然后每经过一个往返时间（RTT）就将**拥塞窗口**加倍，直到达到慢启动阈值或出现拥塞信号为止。

TCP拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复四个部分。

- 慢启动：在TCP连接建立后，发送方初始拥塞窗口大小为1个MSS，然后每经过一个往返时间（RTT）就将拥塞窗口加倍，直到达到慢启动阈值或出现拥塞信号为止。
- 拥塞避免：当拥塞窗口达到慢启动阈值后，发送方会进入拥塞避免阶段。在这个阶段中，发送方每经过一个RTT就将拥塞窗口增加1个MSS，以线性增长的方式来控制发送速率。
- 快速重传和快速恢复：当发送方收到3个重复的ACK时，会认为发生了丢包，并立即重传丢失的报文段，而不是等待超时重传。同时，发送方会将慢启动阈值减半，并将拥塞窗口设置为慢启动阈值加3个MSS，然后进入快速恢复阶段。在快速恢复阶段中，发送方每收到一个新的ACK就将拥塞窗口增加1个MSS，直到收到新的数据确认为止。

### 出错控制

MSS（最大报文段长度）是指TCP报文段中数据部分的最大长度。发送方在发送数据时会根据MSS来确定每个TCP报文段的大小，以便保证每个报文段都能够在不分片的情况下通过网络传输。

如果发送方发送的TCP报文段长度超过了MSS，那么这个报文段在经过网络传输时可能会被分片，这会增加网络传输的开销和出错的概率。因此，发送方在发送数据时会根据MSS来确定每个TCP报文段的大小，**以保证每个报文段都不会超过MSS**。

由于我们不能从数据内容判断数据在传输过程中是否丢失，TCP将这个信息写在头部中。具体来说，发生方发生的TCP报文头部有一个序号，表示当前数据的开始字节序号；接收方可以通过上一次接收到的长度，计算这个报文是否是连续的，确认是否出现遗漏。

当然，数据报文在网络传输过程中可能不能按序到达（发送方可以连续发送许多个报文，而不必等待接收方的确认报文）。例如有报文1 2 3 4 5，而5和4先到达，接收方会缓存这两个报文，并返回两个重复的ACK，用来确认它已经收到的最后一个按序到达的报文段，当接收方收到报文段1、2和3后，它会将所有报文段重新排序，并将数据按照顺序传递给应用程序。

当发送方收到一个重复的ACK时，它不会立即采取任何动作。但是，**当发送方连续收到3个重复的ACK时**，它会认为发生了丢包，并立即重传丢失的报文段，而不是等待超时重传。这种机制被称为快速重传，它可以加快丢包恢复的速度，提高TCP协议的传输效率。在TCP协议中，报文段在网络传输过程中可能会发生乱序，这是正常现象。

**当接收方收到一个失序的TCP报文段时，它会返回一个重复的ACK**，用来确认它已经收到的最后一个按序到达的报文段。但是，这并不意味着发生了丢包。如果发送方在收到一个重复的ACK时就立即触发快速重传机制，那么它可能会误判丢包，并进行不必要的重传，这会降低TCP协议的传输效率。因此，快速重传机制要求发送方在收到3个重复的ACK时才触发，以减少误判丢包的概率。

### 重传例子

假如A收到了序号为5、4的报文，而没有收到，1、2、3报文，那么它会发送一个确认号，告诉发送方它期望收到的下一个报文段的序号。在这种情况下，接收方会发送一个确认号为1的报文，因为它期望收到序号为1的报文。这个时候接收方只发送了两个确认号为1的报文，并不会触发发送方的重传机制。**但是**，TCP协议还有一个重传定时器，当定时器超时时，发送方会认为报文丢失并重新发送报文。因此，**即使第三个报文一直没有到达，发送方仍然可以通过重传定时器来触发重传机制**。

### 和UDP的对比

TCP（传输控制协议）是一种面向字节流的协议。这意味着TCP将应用程序发送的数据视为一个连续的字节流，而不是单独的数据包。TCP负责将数据分段并发送到目的地，然后在接收端重新组装数据。由于TCP提供了可靠的传输服务，因此它能够确保数据按顺序到达，并且不会丢失或重复。

相比之下，UDP（用户数据报协议）是一种面向数据报的协议。这意味着UDP将应用程序发送的数据视为单独的数据报，并将其直接发送到目的地。UDP不保证数据报的顺序或可靠性，因此接收端可能会收到乱序、丢失或重复的数据报。

### TCP数据分段

TCP（传输控制协议）是一种面向字节流的协议，它将应用程序发送的数据视为一个连续的字节流。这意味着TCP会将数据分段，**每个段都包含一定数量的字节，并在每个段前面添加TCP头信息**，然后将这些段封装在IP数据包中发送到目的地。

在接收端，TCP会从IP数据包中提取出TCP段，并根据序列号重新组装数据。由于TCP提供了可靠的传输服务，因此它能够确保数据按顺序到达，并且不会丢失或重复。

总之，TCP并不会将数据包转换成二进制，而是将数据分段并添加TCP头信息，然后封装在IP数据包中发送到目的地。

如果你发送的数据很小，达不到TCP规定的段大小，TCP会使用一个称为Nagle算法的技术来确定何时发送数据。

Nagle算法旨在减少网络中小数据包的数量。它通过将多个小数据包组合成一个较大的数据包来实现这一目标。当应用程序发送一些小数据时，TCP并不会立即发送这些数据，而是将它们存储在缓冲区中。只有当缓冲区中的数据量达到一定大小时，TCP才会将这些数据组合成一个较大的数据包并发送出去。

**此外**，应用程序也可以通过设置TCP_NODELAY选项来禁用Nagle算法。当禁用Nagle算法时，TCP会立即发送所有数据，而不管它们的大小。

但是，Nagle算法并不总是等待缓冲区中的数据量达到一定大小才发送数据。**如果之前发送的数据已经得到了确认，那么TCP会立即发送缓冲区中的所有数据，而不管它们的大小。**

---

## Cookie

服务器要发送多个 cookie，则应该在同一响应中**发送多个** **`Set-Cookie`** 标头。

### 客户端设置

- 使用`document.cookie`属性创建、修改和读取`cookie`。服务端可以设置`set-cookie`的 `httponly`字段禁止通过js访问cookie。
  `document.cookie = "username=John Doe"`。 您还可以为cookie添加一个过期时间（以UTC或GMT时间）。默认情况下，cookie在浏览器关闭时删除： `document.cookie = "username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT"`。 您可以使用path参数告诉浏览器cookie的路径。默认情况下，cookie属于当前页面。 `document.cookie = "username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/" `。

  **如果**客户端尝试通过`document.cookie`修改带有`HttpOnly`属性的cookie，脚本不会出错，但是修改操作不会成功。

### 服务端设置

- 服务器可以在响应标头里面添加一个或多个Set-Cookie选项来设置Cookie。例如，服务器可以发送一个名为yummy_cookie，值为choco的Cookie： `Set-Cookie: yummy_cookie=choco`。

### 字段

- **SameSite**
- **domain**
- **Secure**
- path
- HttpOnly
- Expires，max-age；不设置的话cookie会在客户端关闭时清除；

## WebSocket

**WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的**，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。

建立了WenSocket之后服务器不必在浏览器发送request请求之后才能发送信息到浏览器。这时的**服务器已有主动权**想什么时候发就可以发送信息到服务器。而且信息当中不必在带有head的部分信息了与http的长链接通信来说，这种方式，不仅能降低服务器的压力。而且信息当中也减少了部分多余的信息。WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。

---

WebSocket是一种双向的，全双工的协议，用于客户端和服务器之间的通信，与HTTP不同，它以ws://或wss://开头。12 它是一种有状态的协议，也就是说客户端和服务器之间的连接会保持活跃，直到被任何一方终止。

WebSocket的原理是基于HTTP协议的，它通过**一个HTTP请求**来建立连接（之后都是TCP），这个请求包含一个Upgrade头，表示要升级到WebSocket协议。345 如果服务器支持WebSocket协议，它会返回一个101状态码和一个Sec-WebSocket-Accept头，表示同意升级。345 这样就建立了一个TCP连接，客户端和服务器端就可以通过这个连接直接交换数据。

WebSocket可以在任何版本的HTTP协议上构建，但是需要浏览器和服务器都支持WebSocket协议。
