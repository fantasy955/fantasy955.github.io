## keep-alive

> [HTTP协议的Keep-Alive 模式 - 简书 (jianshu.com)](https://www.jianshu.com/p/49551bda6619)
>
> HTTP的Keep-Alive与TCP的Keep Alive，有些不同，两者意图不一样。前者主要是 TCP连接复用，避免建立过多的TCP连接。而TCP的Keep Alive的意图是在于保持TCP连接的存活，就是发送心跳包。

## TLS协议4次握手

传输层安全性协议（英语：Transport Layer Security，缩写作TLS）

> 由于 HTTPS 的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时，IETF 对 SSL3.0 进行了标准化，并添加了少数机制(但是几乎和 SSL3.0 无差异)，标准化后的 SSL 更名为 TLS1.0(Transport Layer Security 安全传输层协议)，可以说 TLS 就是 SSL 的新版本3.1，并同时发布 “RFC2246-TLS 加密协议详解”。

使用非对称加密算法生成密钥，并交换密钥。

- **客户端发出请求Client Hello**

  首先，客户端先向服务器发出加密通信的请求，这被叫做clienthello请求。

  在这一步，客户端主要向服务器提供以下信息：

  **支持的协议版本**，比如TLS1.0版本；
  **支持的加密方法**，比如RSA公钥加密；
  **一个客户端生成的随机数**(client random), 稍后用于生成对话密钥(session key)
  由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。

- **服务器回应Server Hello**

  服务器收到客户端请求后，向客户端发出回应，这叫做serverhello。

  这一步服务器主要干三件事：

  确认使用的加密通信协议版本，比如TLS1.00版本。如果游览器与服务器支持的版本不一致，服务器关闭加密通信；
  确认使用的加密方法（客户端所支持），比如RSA公钥加密；
  将**服务器证书**、**非对称加密的公钥**，以及**一个随机数(Server random)**发送给客户端游览器
  服务端在接收到客户端的Client Hello之后，服务端需要将自己的证书发送给客户端。这个证书是对于服务端的一种认证。例如，客户端收到了一个来自于称自己是http://www.alipay.com的数据，但是如何证明对方是合法的alipay支付宝呢？这就是证书的作用，**支付宝的证书可以证明它是alipay**，而不是财付通。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。

- 客户端回应

  客户端收到服务器回应以后，首先**验证服务器证书**，验证手段就是执行如下三种检查：

  检查证书**是否已过期**；
  检查证书中的域名与**实际域名是否一致**；
  检查证书是否是**可信机构颁布**的；
  如果，上述过程中有任何一个环节发现问题，那么浏览器就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书受信任，或者是用户接受了不受信的证书，**浏览器会生成一串新的随机数（Premaster secret ）**，并用证书中提供的公钥加密，发送给服务器。

  此时，浏览器会根据前三次握手中的三个随机数：

  ​	Client random
  ​	Server random
  ​	Premaster secret

  客户端收到服务端的回复后利用服务端的**公钥**，加上**新的随机数–Premaster secret** 通过服务端下发的**公钥及加密方法**进行加密，得到**会话密钥（Premaster secret）**，发送给服务器。

- 服务端回应

  服务端收到客户端的回复，利用已知的加密解密方式进行解密，服务器收到客户端的第三个随机数（ Premaster secret） 之后，使用同样的算法计算出 **“会话密钥” （Session Key）**。

  至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 “会话密钥” 加密内容。（非对称加密解密将不再使用，接下来完全由对称加密接手了，因为密钥已经安全的传送给了通信的双方）

`Premaster secret`使用**服务端公钥**进行非对称加密，必须使用**服务端的私钥**进行解密。即使数据在输出中被其他人得到，也无法解密出`Premaster secret`。

服务端解密出`Premaster secret`，使用相同的算法生成**会话密钥**，由于会话密钥没有在客户端与服务端的通信中出现，第三方无法解密传输的信息。

第一次和第二次握手用于确定加密算法和交换随机数。这阶段的信息是明文传输的。第三方可以获得客户端随机数和服务端随机数。

第三次握手客户端使用非对称加密算法，借助服务器公钥，加密`Premaster secret`。第三方无法获取这个随机数，因为他们没有私钥进行解密。同时，会话密钥已经能够计算出来，但是其他人没有`Premaster secret`，无法计算。因此，正向和逆向都无法获得会话密钥。

## HTTPS如何防止信息被劫持

两个方面，一是客户端会验证服务器的证书，保证服务器身份的真实性。二是通过TLS协议保证传输数据的安全。

---

## 跨域

最常用的两种应该是jsonp和cors，剩余一种是nginx反向代理。反向代理解决跨域问题的原理是通过伪造请求使得HTTP请求为同源的，然后将同源的请求发送到反向代理服务器上，由反向代理服务器去请求真正的URL，这样就绕过直接请求真正的URL导致跨域问题。

jsonp的有点是没有兼容性问题，是否调用后端返回的回调方法也是有前端决定的。其原理是script标签的src属性不受同源策略的影响，后端返回的内容会被替换到script标签中。前端定义了一个函数并挂载到window对象上，函数的参数由后端提供，后端返回的字符串是调用该函数并且传递参数。缺点是请求失败并不会返回HTTP状态码，无法进行出错处理。只支持Get请求。

CORS是一种运行跨域资源共享的策略。CORS的缺点是会降低服务器的安全性，特别是允许任何源访问资源。CORS还需要额外的预检请求，增加了网络开销。

---

## HTTP1.0 、 HTTP1.1和HTTP2.0

http1.0是无状态无连接的应用层协议，无连接特性导致每次发送HTTP请求都会与服务器新建一个TCP连接，浪费时间与流量在TCP连接的建立过程。并且HTTP1.0规定，请求必须在前一个请求的响应到达后才能发送，如果前一个请求的响应不到达，就会阻塞后面的请求。

HTTP1.1增加了一个connection字段，可以保持连接不断开，避免每次请求都重复建议TCP连接，提高了网络的利用率。到由于只有一个TCP连接，很容易产生队头阻塞的情况（服务器可以收到多个HTTP请求，但是必须按照客户端请求的顺序返回）。因此另一种并行，即浏览器创建多个TCP连接，是更加常用的并行方法。

**个人理解：**

在HTTP1.0和1.1中，HTTP报文是一个整体，如果多个HTTP混合在一起传输，无法还原HTTP报文。（在底层传输过程中，HTTP报文会被转换成二进制串并拆分，并以二进制进行传输，在上层进行还原。）

HTTP2.0提出了流和帧的概念，一个TCP连接可以包含多个流，一个流包含多个帧。一个流可以包含多个HTTP请求/响应（都是消息）。帧有一个标识符标记自己属于哪一个流，那么一个流中不同消息的帧又如何区分呢？——在同一个流中，同一个消息的帧必须依次发送；只有不同流中的消息和帧才可以交错发送。HTTP2.0中有一种帧叫做RST_STREAM帧，它可以用来终止一个流。

其中最重要的是流的概念，这让多个HTTP请求/响应可以同时传输（属于不同流），而以前可以认为只有一个流。

为什么一个流要包含多个消息呢？不能直接创建一个新的流吗？

[HTTP2.0不直接使用一个流的原因可能是为了避免队头阻塞](https://zhuanlan.zhihu.com/p/102561034)[1](https://zhuanlan.zhihu.com/p/102561034)[。如果只有一个流，那么所有的请求和响应都要按照顺序发送和接收，如果某个请求或响应被阻塞，那么后面的所有请求或响应也会被阻塞，导致客户端迟迟收不到数据](https://zhuanlan.zhihu.com/p/102561034)[1](https://zhuanlan.zhihu.com/p/102561034)[。而HTTP2.0中使用多个流，可以实现并行传输，不同流中的帧可以交错发送和接收，不会因为某个流的阻塞而影响其他流](https://zhuanlan.zhihu.com/p/89471776)[2](https://zhuanlan.zhihu.com/p/89471776)[3](https://juejin.cn/post/7034668672262242318)。

[一个流包含多个消息的原因是为了提高传输效率和利用带宽。如果每个消息都创建一个新的流，那么就会增加流的数量和管理的复杂度，而且可能会导致一些流被闲置或者浪费](https://blog.csdn.net/qq_34629352/article/details/105467221)[1](https://blog.csdn.net/qq_34629352/article/details/105467221)[2](https://zhuanlan.zhihu.com/p/89471776)[。HTTP2.0中，一个流可以承载双向消息传输，也就是说客户端和服务器可以在同一个流中发送和接收多个请求和响应](https://zhuanlan.zhihu.com/p/89471776)[2](https://zhuanlan.zhihu.com/p/89471776)[3](https://zhuanlan.zhihu.com/p/405149337)[。这样就可以减少TCP连接的数量，节省握手的时间，提高并发性能](https://blog.csdn.net/qq_34629352/article/details/105467221)[1](https://blog.csdn.net/qq_34629352/article/details/105467221)[2](https://zhuanlan.zhihu.com/p/89471776)。



HTTP2.0报文的头部长度不是固定的，而是根据实际情况动态变化的。**HTTP2.0使用了HPACK算法来对头部进行压缩**，减少了头部的大小和冗余。HPACK算法使用了两种方法来压缩头部：静态表和动态表。静态表是一个预定义的常用头部字段的列表，动态表是一个根据请求和响应过程中出现的头部字段动态更新的列表。这样，HTTP2.0可以通过发送索引值来代替完整的头部字段，从而节省带宽和提高效率。

HTTP2.0报文通过二进制分帧来将HTTP语义信息（如头部，请求方法，状态码等）和应用数据（如HTML，CSS，JS等）分离，并封装成不同类型的帧。每个帧都有一个固定的9字节的头部，包含了帧类型，长度，标志位和流标识符。不同类型的帧有不同的作用和格式。例如，HEADERS帧用于传输HTTP头部信息，DATA帧用于传输应用数据，SETTINGS帧用于传输连接配置参数等。

HTTP2.0报文有10种类型的帧，分别是**DATA**，**HEADERS**，PRIORITY，RST_STREAM，SETTINGS，**PUSH_PROMISE**，PING，GOAWAY，WINDOW_UPDATE和CONTINUATION。每种帧都有不同的作用和格式1。例如，DATA帧用于传输应用数据，HEADERS帧用于传输HTTP头部信息，PRIORITY帧用于指定流的优先级等1。

二进制分帧有很多优点。首先，**它可以将HTTP语义信息和应用数据分离**，并封装成不同类型的帧。这样可以实现多路复用（multiplexing），即在一个TCP连接上同时传输多个请求和响应。这样可以减少TCP连接的数量和开销，并提高网络利用率。其次，它可以实现流控制（flow control），即根据接收方的能力来调整发送方的速度。这样可以避免发送方过载接收方，并保证数据传输的平衡和稳定。第三，它可以实现优先级（priority），即根据不同流的重要性来分配资源和顺序。这样可以提高用户体验和响应速度，并避免低优先级的流阻塞高优先级的流。

二进制分帧也有一些机制来保证顺序性和完整性。首先，在每个帧头部都有一个流标识符（stream identifier），用于标识该帧属于哪个流。这样就可以将不同类型的帧按照所属流进行组合和解析，并保证每个流内部的顺序性。其次，在每个DATA帧头部都有一个结束标志位（END_STREAM），用于标识该DATA帧是否是该流中最后一个DATA帧  \[^1 ^\] [ ^2 ^] [ ^9 ^]. 这样就可以判断该流是否已经完成了数据传输，并保证每个流内部的完整性[ ^9 ^]. 第三，在每个HEADERS 帧头部都有一个连续标志位（END_HEADERS），用于标识该HEADERS 帧是否是该头部块中最后一个HEADERS 帧[ ^1 ^] [ ^2 ^] [ ^9 ^]. 这样就可以判断该头部块是否已经完成了头部信息传输，并保证每个头部块内部的完整性[ ^9 ^].

## 服务器推送

举例：客户端请求一个html文件，服务端把html文件以及其他资源文件一起返回给前端。

---

## HTTP请求/响应的常用头部

常用的通用头部字段：

Cache-Control、Connection、

常用的请求头部字段：

- [Accept：指定客户端能够接收的内容类型](https://www.cnblogs.com/lauhp/p/8979393.html)[1](https://www.cnblogs.com/lauhp/p/8979393.html)。
- [Accept-Charset：浏览器可以接受的字符编码集](https://www.cnblogs.com/lauhp/p/8979393.html)[1](https://www.cnblogs.com/lauhp/p/8979393.html)。

If-Match、If-Modified-Since、If-None-Match、If-Range、Range

常用的响应头部字段：

Accept-Ranges（表示接收字节的请求范围）、ETag、Location（用于重定向，指向重定向的链接）

---

