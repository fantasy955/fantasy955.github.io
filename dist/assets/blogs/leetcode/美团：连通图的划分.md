# 题目

[美团 2021 届秋季校园招聘笔试真题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/meituan/ohc3t1/)

> 小美是美团总部的高管，她想要召集一些美团的区域负责人来开会，已知美团的业务区域划分可以用一棵树来表示，树上有 n 个节点，每个节点分别代表美团的一个业务区域，每一个区域有一个负责人，这个负责人的级别为 A[i]
> 已知小美召集人员开会必须满足以下几个条件：
> 1.小美召集的负责人所在的区域必须构成一个非空的连通的图，即选取树上的一个连通子图。
> 2.这些负责人中，级别最高的和级别最低的相差不超过 k 。
> 请问小美有多少种召集负责人的方式，当且仅当选取的集合不同时我们就认为两种方式不同。由于方案数可能非常大，所以请对 10^9+7 取模。
>
> 作者：美团
> 链接：https://leetcode.cn/leetbook/read/meituan/ohc3t1/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**格式：**

> 输入：
> - 输入第一行包含两个整数 n 和 k ，表示区域的数量，和不能超过的级别。
> - 接下来有 n-1 行，每行有两个正整数 a 和 b ，表示 a 号区域和 b 号区域有一条边。
> - 最后一行有 n 个整数，第 i 个整数表示 i 号区域负责人的级别。
> 输出：
> - 输出仅包含一个整数，表示可以选择的方案数对 10^9+7 取模之后的结果。
>

**示例：**

> 输入：
>      5 1
>      1 2
>      2 3
>      3 4
>      4 5
>      2 2 2 2 2
> 输出：15
> 解释：显然一个区域的方案有 {1}，{2}，{3}，{4}，{5}，两个区域的方案有 4 个，三个区域的方案有 3 个，四个区域的方案有 2 个，五个区域的方案有 1 个，共 15 个。

## 错误尝试

最开始的思路是先确定满足条件（等级差不超过k）的连通子图区域个数，再计算每个子图划分的可能性；

但这种方法忽略了将子图再次划分时的连通问题（只单纯考虑了集合的划分个数），无法正确计算出答案

```c++
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
#include<math.h>
using namespace std;
int MOD = pow(10, 9) + 7;

int visitMap(int i, vector<bool>& visited, vector<vector<int>>& map, vector<int>& sonMapIndex, int& n, int& k, unordered_map<int, int>& sonMapSize){
    int res = 1;
    for(int j=1; j<=n; j++){
        if (!visited[j] && map[j][0] > map[i][0] && map[i][j] == 1 && abs(map[i][0]-map[j][0]) <= k){
            sonMapIndex[j] = sonMapIndex[i];
            sonMapSize[sonMapIndex[i]]++;
            visited[j] = true;
            res *= (1+visitMap(j, visited, map, sonMapIndex, n, k, sonMapSize)) % MOD;
        }
    }
    return res;
}

int main(){
    int n, k;
    cin >>n>>k;
    vector<vector<int>> map(n+1);
    for(int i=0; i<=n; i++){
        map[i].resize(n+1);
    }
    int a, b;
    for(int i=0; i<n-1; i++){
        cin >>a>>b;
        map[a][b] = 1;
        map[b][a] = 1;
    }

    int level;
    for(int i=1; i<=n; i++){
        cin>>level;
        map[i][0] = level;
    }
    
    vector<int> sonMapRoot;
    vector<bool> visited(n+1, false);
    vector<int> sonMapIndex(n+1, 0);
    unordered_map<int, int> sonMapSize;
    int mapIndex = 0;
    int maxSize = 0x80000000;
    for(int i=1; i<=n; i++){
        if (!visited[i]){
            mapIndex++;
            sonMapSize[mapIndex] = 1;
            visited[i] = true;
            sonMapIndex[i] = mapIndex;
            visitMap(i, visited, map, sonMapIndex, n, k, sonMapSize);
            sonMapRoot.push_back(i);
        }
        maxSize = maxSize > sonMapSize[mapIndex] ? maxSize : sonMapSize[mapIndex];
    }
    vector<int> size2count(maxSize+1, 2);
    size2count[1] = 1;
    size2count[2] = 2;
    // 构造子图时要考虑连通性，所以不能单纯地计算子集数量
    for(int i=3; i<=maxSize; i++){
        for(int j=1; j<i; j++){
            size2count[i] += (size2count[j] * size2count[i-j]);
        }
    }
  int ans = 1;
  for(int son=0; son<sonMapRoot.size(); i++){
    int root = sonMapRoot[son];
    int index = sonMapIndex[root];
    int size = sonMapSize[index];
    ans *= size2count[size];
  }
  cout<<ans<<endl;

    return 0;
}
```

# 正确思路

在遍历图时统计数量；

枚举**每一个点必选**的情况下所能组成的子集数量，为了避免重复，我们可以在寻找子集时只统计不小于当前点的level的所有点。

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<math.h>
using namespace std;
int MOD = pow(10, 9) + 7;

int visitMap(int u, int s, vector<bool>& visited, vector<vector<int>>& edges, vector<int>& level, int& n, int& k){
    int res = 1;
    visited[u] = true;
    for(int v: edges[u]){
        if (visited[v] == true) continue;
        if (level[v] > level[s] && level[v] - level[s] <= k 
            || level[v] == level[s] && v > s){
                res = res * (1+visitMap(v, s, visited, edges, level, n, k)) % MOD;
        }
    }
    return res;
}

int main(){
    int n, k;
    cin >>n>>k;
    vector<vector<int>> edges(n+1);
    int a, b;
    for(int i=0; i<n-1; i++){
        cin >>a>>b;
        edges[a].push_back(b);
        edges[b].push_back(a);
    }

    vector<int> level(n+1);
    for(int i=1; i<=n; i++){
        int tmp;
        cin >>tmp;
        level[i] = tmp;
    }
    
    vector<bool> visited(n+1);
    int mapIndex = 0;
    int ans = 0;
    for(int i=1; i<=n; i++){
        fill(visited.begin(), visited.end(), false);
        ans = (ans + visitMap(i, i, visited, edges, level, n, k)) % MOD;
    }
    cout<<ans<<endl;

    return 0;
}
```

## 理解难点

**等待填坑**

- 递归的统计问题

```c++
res = res * (1+visitMap(v, s, visited, edges, level, n, k)) % MOD;
```

- 判断进行递归的条件

```c++
if (level[v] > level[s] && level[v] - level[s] <= k 
            || level[v] == level[s] && v > s){
```

- 最外层统计（main函数内）为什么是用加法

```c++
ans = (ans + visitMap(i, i, visited, edges, level, n, k)) % MOD;
```
