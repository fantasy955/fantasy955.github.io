# 题目

[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/submissions/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/jump-game-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 解题

在初始位置`0`，所需要的步数为0，其能够到达的位置所需步数为1；

处在位置`i`，记到达当前位置的最小开销为`steps2[i]`，当前位置能跳跃的步数为`power: nums[i]`，那么从`i+1`到`i+power`位置的最小开销为$min(steps2[i+j], steps2[i]+1),j\in[i+1,i+power]$，

# 代码

```c++
#define MAX_INT 0x7fffffff
#define min(a, b) a<b?a:b
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if (n==1){
            return 0;
        }
        vector<int> steps2(n, MAX_INT);
        steps2[0] = 0;
        for(int i=0; i<n; i++){
            int power = nums[i];
            if (i+power >= n-1){
                return steps2[i] + 1;
            }
            for(int j =0; j<=power; j++){
                steps2[i+j] = min(steps2[i] + 1, steps2[i+j]);
            }
        }
        return -1;
    }
};
```

# 结果

![image-20220816112100181](assets/image-20220816112100181.png)

# 优化

- 取消不必要的遍历

若`steps2[i]`不等于`Max_INT`，则其当前的步数一定是最小的。

```c++
for(int j =power; j<=power && steps2[i+j] == MAX_INT; j--){
	steps2[i+j] = min(steps2[i] + 1, steps2[i+j]);
}
```

![image-20220816112111159](assets/image-20220816112111159.png)

320ms -> 16 ms