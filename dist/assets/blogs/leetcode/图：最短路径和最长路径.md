# 题目

[美团 2021 届秋季校园招聘笔试真题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/meituan/ohfw76/)



# 任意两点最短路径

```
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            for (int c = 1; c <= n; c++){
                if (minPath[i][c] != 0 && minPath[c][j] != 0){
                    if (minPath[i][j] == 0){
                        minPath[i][j] = minPath[i][c] + minPath[c][j];
                        minPath[j][i] = minPath[i][j];
                    }else{
                        minPath[i][j] = min(minPath[i][j], minPath[i][c] + minPath[c][j]);
                        minPath[j][i] = minPath[i][j];
                    }
                }
            }
        }
    }
```



# 小团无路可逃

> 小团惹小美生气了，小美要去找小团“讲道理”。小团望风而逃，他们住的地方可以抽象成一棵有n个结点的树，小美位于 x 位置，小团位于 y 位置。小团和小美每个单位时间内都可以选择不动或者向相邻的位置转移，很显然最终小团会无路可逃，只能延缓一下被“讲道理”的时间，请问最多经过多少个单位时间后，小团会被追上。
>
> 作者：美团
> 链接：https://leetcode.cn/leetbook/read/meituan/ohfw76/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 解题

这题的关键在于简化问题, 题中的最多时间表述不清楚, 应该是在不浪费时间的情况下, 追上小团的最长时间, 即小美一定要向小团移动.

小团直接向距离小美最远的节点, 同时要保证自己离该节点的距离小于小美离该节点的距离(保证小团跑向该节点时, 不好经过小美).

同时小美不会预先指定小团的目的地, 因此只会在后面追小团, 不会提前拦截.

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4+1;
vector<int> edge[N];
int m[N], disx[N], disy[N];
void dfs(int root, int deep, int *dis)
{
    dis[root] = deep;
    m[root] = 1;
    for (auto i : edge[root])
    {
        if (!m[i])
            dfs(i, deep + 1, dis);
    }
    //m[root]=0;
}
int main()
{
    int n, x, y;
    cin >> n >> x >> y;
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    memset(m, 0, sizeof m);
    dfs(x, 0, disx);
    memset(m, 0, sizeof m);
    dfs(y, 0, disy);
    // cout<<"****"<<disy[1]<<endl;
    int Max = 0;
    for (int i = 1; i <= n; i++)
    { // 跑到一个距离x最远的地方，则x需要最久的时间到达
       // 小团距离该节点更近,说明不会经过小美的节点.
        if (disy[i] < disx[i])
        {
            Max = max(Max, disx[i]);
        }
    }
    cout << Max << endl;
    return 0;
}
```