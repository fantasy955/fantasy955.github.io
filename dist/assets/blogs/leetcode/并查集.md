# 题目

[美团 2021 届秋季校园招聘笔试真题 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/meituan/oh4ykh/)

[952. 按公因数计算最大组件大小 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-component-size-by-common-factor/)



# 构造并查集

```c++
const int n = 10;
vector<int> parent(n);
// rank 记录根节点的优先级， 说明其分支越多
vector<int> rank(n);

// 初始化父节点为自身
// 因此寻找父节点的终止条件为 x == parent[x]
for (int i = 0; i < n; ++i){
    parent[i] = i;
}

// 寻找x的根节点
int find(int x){
    return x == parent[x] ? x : find(parent[x]);
}

// 可以降低复杂度
int find(int x){
    if(x != parent[x]){
      parent[x] = find(parent[x]);
    }
  return parent[x];
}

// 把y合并到x的集合中，把rooty的父节点设为rootx
void uni(int x, int y){
    int rootx = find(x);
    int rooty = find(y);
    if (rootx == rooty){
        // x y属于同一集合
    }else{
        if(rank[rootx] < rank[rooty]){
            parent[rootx] = rooty;
        }else if (rank[rootx] > rank[rooty]){
            parent[rooty] = rootx;
        }else{
            // 同级默认合并到rootx
            parent[rooty] = rootx;
            rank[rootx]++;
        }
    }
}
```



# 美团 

https://leetcode.cn/leetbook/read/meituan/oh4ykh/

```c++
#include <iostream>
#include <vector>
#define max(a, b) a > b ? a : b
using namespace std;

vector<int> parent;
vector<int> sz;
int res = 0;

int find(int x){
    return x == parent[x] ? x : find(parent[x]);
}

// 调用时已经规定了方向
// 返回当前最大的连续货物的重量
int uni(int x, int y){
    int rootx = find(x);
    int rooty = find(y);
    if (rootx == rooty){
        return res;
    }
    parent[rooty] = rootx;
    sz[rootx] += sz[rooty];
    return max(res, sz[rootx]);
}

int main(){
    int n;
    cin >> n;
    int num;
    vector<int> weight(n);
    vector<int> outOrder(n);
    parent.resize(n);
    sz.resize(n);
    for (int i = 0; i < n; i++){
        cin >> num;
        weight[i] = num;
        parent[i] = i;
        sz[i] = num;
    }
    for (int i = 0; i < n; i++){
        cin >> num;
        outOrder[i] = num-1;
    }

    // tmp[i]: i是否放入
    vector<bool> tmp(n, false);
    vector<int> vec(n);

    // i 一定不会插入已经存在的连续货物中（悖论，如果货物连续，则物品一定以及放入）
    // 因此只需要记录放入前的最大连续货物重量即可。
    for (int i = n - 1; i >= 0; i--){
        vec[i] = res;
        int j = outOrder[i];
        res = max(res, weight[j]); // 更新最大重量
        if (j + 1 < n && tmp[j + 1]){
            res = uni(j, j + 1); //将右侧货物重量合并到当前放的这个货物上
        }
        if (j > 0 && tmp[j - 1]){
            res = uni(j - 1, j); //将当前货物重量合并到左侧货物上
        }
        tmp[j] = true;
    }
    for(int x : vec)
        cout << x << endl;

    return 0;
}
```



# 力扣 

https://leetcode.cn/problems/largest-component-size-by-common-factor/

```c++
vector<int> parent;
vector<int> ranked; 

int find(int x){
    if(x != parent[x]){
       parent[x] = find(parent[x]);
    }
    return parent[x];
}

// 合并x，y所属的两个集合
void uni(int x, int y){
    int rootx = find(x);
    int rooty = find(y);
    if (rootx != rooty){
        if (ranked[rootx] > rooty){
            parent[rooty] = rootx;
        }else if(ranked[rootx] < rooty){
            parent[rootx] = rooty; 
        }else{
            parent[rooty] = rootx;
            ranked[rootx]++;
        }
    }
}
class Solution {
public:
    int largestComponentSize(vector<int>& nums) {
        int maxNum = *max_element(nums.begin(), nums.end());
        // UnionFind uf(maxNum+1);
        parent.resize(maxNum+1);
        ranked.resize(maxNum+1);
        for(int i=0; i<maxNum+1; i++){
            parent[i] = i;
        }
        for(int num: nums){
            for(int i=2; i*i<= num; i++){
                if (num % i == 0){
                    uni(num, i);
                    uni(num, num/i);
                }
            }
        }

        vector<int> count(maxNum+1);
        int ans = 0;
        for(int num: nums){
            int root = find(num);
            count[root]++;
            ans = ans > count[root] ? ans : count[root];
        }
        return ans;
    }
};
```

