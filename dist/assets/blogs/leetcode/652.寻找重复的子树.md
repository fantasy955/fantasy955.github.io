# 题目

[652. 寻找重复的子树 - 力扣（LeetCode）](https://leetcode.cn/problems/find-duplicate-subtrees/)

> 给定一棵二叉树 root，返回所有重复的子树。
>
> 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。
>
> 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。
>
>  
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/find-duplicate-subtrees
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

**示例 1：**

![img](assets/e1.jpg)

```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

# 分析

对于重复的树，只输出一个根节点的值；

子树内的重复树也输出（示例中[2, 4]的子树[4]）。

**如何唯一定义一棵树的结构：**

- 先续遍历+中序遍历（中序遍历确定根节点，中序遍历确定左右子树）
- ...

# 代码

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

 // 先序和中序确定一颗树
 // 先序确定根，中序确定左右
 // 后序遍历无法确定子节点在左还是在右
class Solution {
private:
		// 保存以key节点为根的先序遍历结果
    unordered_map<TreeNode*, vector<int>> node2preOrderList;
    // 保存以key节点为根的中序遍历结果
    unordered_map<TreeNode*, vector<int>> node2inOrderList;
    // 第i棵重复子树的先序遍历序列，用于保证重复的树只输出一次
    vector<vector<int>> duplicateSubtreesPreOrderList;
    // 第i棵重复子树的中序遍历序列
    vector<vector<int>> duplicateSubtreesInOrderList;

public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        vector<TreeNode*> ans;
        visitTree(root, ans);
        return ans;
    }

    void visitTree(TreeNode* root, vector<TreeNode*>& ans){
        if (root == nullptr){
            return;
        }

        node2preOrderList[root].push_back(root->val);
        if (root->left != nullptr){
            visitTree(root->left, ans);
            // 将左子树的先序遍历和后续遍历结果按顺序添加到该节点
            for(int val: node2preOrderList[root->left]){
                node2preOrderList[root].push_back(val);
            }
            for(int val: node2inOrderList[root->left]){
                node2inOrderList[root].push_back(val);
            }
        }else{
            node2preOrderList[root].push_back(-201);
            node2inOrderList[root].push_back(-201);
        }
        node2inOrderList[root].push_back(root->val);
        if(root->right != nullptr){
            visitTree(root->right, ans);
            for(int val: node2preOrderList[root->right]){
                node2preOrderList[root].push_back(val);
            }
            for(int val: node2inOrderList[root->right]){
                node2inOrderList[root].push_back(val);
            }
        }else{
            node2preOrderList[root].push_back(-201);
            node2inOrderList[root].push_back(-201);
        }
        for(auto iter = node2preOrderList.begin(); iter != node2preOrderList.end(); iter++){
            if (root != iter->first && node2preOrderList[iter->first] == node2preOrderList[root]){
                if (node2inOrderList[iter->first] == node2inOrderList[root]){
                    bool added = false;
                    for(int i=0; i<duplicateSubtreesPreOrderList.size(); i++){
                        if (duplicateSubtreesPreOrderList[i] == (*iter).second && 
                        duplicateSubtreesInOrderList[i] == node2inOrderList[(*iter).first]){
                            added = true;
                            break;
                        }
                    }
                    if (!added){
                        duplicateSubtreesPreOrderList.push_back(iter->second);
                        duplicateSubtreesInOrderList.push_back(node2inOrderList[(*iter).first]);
                        ans.push_back(root);
                    }
                }
            }
        }
    }
};
```

# 运行结果

![image-20220905221557502](assets/image-20220905221557502.png)

每个节点遍历返回时就查询一次造成了多余的时间消耗。