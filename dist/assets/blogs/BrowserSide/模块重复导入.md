# 实例

`increment.js`:

```javascript
let counter = 0;
counter++;
console.log('increment.js')

module.exports = {
    counter
}
```

`b.js`:

```javascript
const inc = require('./increment')

console.log('b', inc.counter)
```

`main.js`:

```javascript
const a = require('./increment')
const b = require('./b')

console.log('main ', a.counter)
```

执行`node main.js`

**输出**:

```
increment.js
b 1
main  1
```

**结论**：

`increment.js`被导入两次，但是其作用域内的代码只执行了一次。

# 原理分析

根据规范，每个 JavaScript 模块都与模块记录相关联。模块记录具有方法 `Evaluate()`，该方法对模块进行评估：

如果该模块已经被成功评估，则返回 `undefined`；……否则，便可递归地评估此模块所有的模块依赖性，然后再评估此模块。

所以同一模块仅被评估一次。

不幸的是，问题不止于此。如何确保使用相同路径两次调用 import 语句返回相同的模块？

将路径(也称为说明符)关联到具体模块的职责由 HostResolveImportedModule() 执行操作。

```typescript
1import module from 'path';
```

根据规则：

> HostResolveImportedModule 的实现必须符合以下要求：
>
> 正常的返回值必须是  Module Record 的具体子类的实例。
>
> 如果与 referencingScriptOrModule, specifier对相对应的 Module Record 不存在或无法创建，则必须引发异常。
>
> 每次使用特定的 referencingScriptOrModule, specifier 对作为参数调用此操作时，如果正常完成，则必须返回相同的 Module Record 实例。
>

让我们以一种易于理解的方式看看都发生了什么。

HostResolveImportedModule(referencingScriptOrModule, specifier) 是一个抽象操作，该操作返回对应于ReferencingScriptOrModule, specifier 的模块：

参数 referencingScriptOrModule 是当前模块，即进行导入的模块。

参数 specifier 是对应 import 语句中模块路径的字符串。

最后，HostResolveImportedModule() 从相同路径导入模块时，将导入相同模块：

```javascript
const a = require('./increment')
const aa = require('./increment')
console.log(a === aa)  // true
```

规范指出主机(浏览器，Node 或任何尝试运行 JavaScript 的东西)必须提供 `HostResolveImportedModule()` 的具体实现。

**结论**：

同一模块仅被评估一次，换句话说，模块级作用于仅被执行一次。如果评估后的模块再次导入，则会跳过第二次评估，并使用已解决的已导出文件。

如果某个模块多次导入但使用相同的说明符(即路径)，则 JavaScript 规范可确保你将得到相同的模块实例。